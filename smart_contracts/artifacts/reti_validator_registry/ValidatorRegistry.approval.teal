#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 264 24 296 576 192 1000000
    bytecblock "v" 0x151f7c75 "init" "numV" 0x0000 0x151f7c750000000000000000 0x151f7c75000000000000000000000000000000000000000000000000 "poolTemplateApprovalBytes" "sps"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txn NumAppArgs
    bz main_after_if_else@41
    pushbytess 0x46f76533 0xb8447b36 0x1b5e82c6 0x79472d83 0x5f7acfd9 0x3172ca9d 0x8a87142d 0xd1366cc3 0x3b045c5c 0x3bab5c22 0x9a7c2248 0x2fa22c4b 0x772a7de4 0x572767d1 0x345485b9 0xfbc63178 0x24498cf4 0xf846dd7a 0x83050501 0x7bbb6c8d 0xf839414a 0x11d737ff 0x3e288972 0xdd5faada 0xdd43d7bf 0xf99ef54d 0xbf7fc7e3 0x3b889b84 0xb16b3b40 0x4df8d86e 0x418fcefc 0xa2dc51b5 0x2873f504 0x0547f4fe 0xcb668358 // method "updateApplication()void", method "createApplication()void", method "initStakingContract(uint64)void", method "loadStakingContractData(uint64,byte[])void", method "finalizeStakingContract()void", method "gas()void", method "getMbrAmounts()(uint64,uint64,uint64,uint64)", method "getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "getNumValidators()uint64", method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint64,address,uint64[4],uint64,uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64)", method "getValidatorState(uint64)(uint64,uint64,uint64,uint64)", method "getValidatorOwnerAndManager(uint64)(address,address)", method "getPools(uint64)(uint64,uint64,uint64)[]", method "getPoolAppId(uint64,uint64)uint64", method "getPoolInfo((uint64,uint64,uint64))(uint64,uint64,uint64)", method "getCurMaxStakePerPool(uint64)uint64", method "doesStakerNeedToPayMBR(address)bool", method "getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]", method "getTokenPayoutRatio(uint64)(uint64[24],uint64)", method "getNodePoolAssignments(uint64)((uint64[3])[8])", method "getNFDRegistryID()uint64", method "addValidator(byte[],(uint64,address,address,uint64,uint64,address,uint64[4],uint64,uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64))uint64", method "changeValidatorManager(uint64,address)void", method "changeValidatorSunsetInfo(uint64,uint64,uint64)void", method "changeValidatorNFD(uint64,uint64,byte[])void", method "changeValidatorCommissionAddress(uint64,address)void", method "changeValidatorRewardInfo(uint64,uint64,address,uint64[4],uint64,uint64)void", method "addPool(uint64,uint64)(uint64,uint64,uint64)", method "addStake(uint64,uint64)(uint64,uint64,uint64)", method "setTokenPayoutRatio(uint64)(uint64[24],uint64)", method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void", method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void", method "findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)", method "movePoolToNode(uint64,uint64,uint64)void", method "emptyTokenRewards(uint64,address)uint64"
    txna ApplicationArgs 0
    match main_updateApplication_route@3 main_createApplication_route@4 main_initStakingContract_route@5 main_loadStakingContractData_route@6 main_finalizeStakingContract_route@7 main_gas_route@8 main_getMbrAmounts_route@9 main_getProtocolConstraints_route@10 main_getNumValidators_route@11 main_getValidatorConfig_route@12 main_getValidatorState_route@13 main_getValidatorOwnerAndManager_route@14 main_getPools_route@15 main_getPoolAppId_route@16 main_getPoolInfo_route@17 main_getCurMaxStakePerPool_route@18 main_doesStakerNeedToPayMBR_route@19 main_getStakedPoolsForAccount_route@20 main_getTokenPayoutRatio_route@21 main_getNodePoolAssignments_route@22 main_getNFDRegistryID_route@23 main_addValidator_route@24 main_changeValidatorManager_route@25 main_changeValidatorSunsetInfo_route@26 main_changeValidatorNFD_route@27 main_changeValidatorCommissionAddress_route@28 main_changeValidatorRewardInfo_route@29 main_addPool_route@30 main_addStake_route@31 main_setTokenPayoutRatio_route@32 main_stakeUpdatedViaRewards_route@33 main_stakeRemoved_route@34 main_findPoolForStaker_route@35 main_movePoolToNode_route@36 main_emptyTokenRewards_route@37

main_after_if_else@41:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    intc_1 // 0
    return

main_emptyTokenRewards_route@37:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:385
    // emptyTokenRewards(validatorId: ValidatorIdType, receiver: arc4.Address): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 5 // 0x151f7c750000000000000000
    log
    intc_0 // 1
    return

main_movePoolToNode_route@36:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:383
    // movePoolToNode(validatorId: ValidatorIdType, poolAppId: uint64, nodeNum: uint64): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_findPoolForStaker_route@35:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:367-371
    // findPoolForStaker(
    //   validatorId: ValidatorIdType,
    //   staker: arc4.Address,
    //   amountToStake: uint64,
    // ): [ValidatorPoolKey, boolean, boolean] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500000000000000000000000000000000000000000000000000
    log
    intc_0 // 1
    return

main_stakeRemoved_route@34:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:359-365
    // stakeRemoved(
    //   poolKey: ValidatorPoolKey,
    //   staker: arc4.Address,
    //   amountRemoved: uint64,
    //   rewardRemoved: uint64,
    //   stakerRemoved: boolean,
    // ): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_stakeUpdatedViaRewards_route@33:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:351-357
    // stakeUpdatedViaRewards(
    //   poolKey: ValidatorPoolKey,
    //   algoToAdd: uint64,
    //   rewardTokenAmountReserved: uint64,
    //   validatorCommission: uint64,
    //   saturatedBurnToFeeSink: uint64,
    // ): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_setTokenPayoutRatio_route@32:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:344
    // setTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:344
    // setTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio {
    callsub setTokenPayoutRatio
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_addStake_route@31:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:336
    // addStake(validatorId: ValidatorIdType, valueToVerify: uint64): ValidatorPoolKey {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 6 // 0x151f7c75000000000000000000000000000000000000000000000000
    log
    intc_0 // 1
    return

main_addPool_route@30:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:328
    // addPool(validatorId: ValidatorIdType, nodeNum: uint64): ValidatorPoolKey {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 6 // 0x151f7c75000000000000000000000000000000000000000000000000
    log
    intc_0 // 1
    return

main_changeValidatorRewardInfo_route@29:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:312-319
    // changeValidatorRewardInfo(
    //   validatorId: ValidatorIdType,
    //   EntryGatingType: uint64,
    //   EntryGatingAddress: arc4.Address,
    //   EntryGatingAssets: FixedArray<uint64, 4>,
    //   GatingAssetMinBalance: uint64,
    //   RewardPerPayout: uint64,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:312-319
    // changeValidatorRewardInfo(
    //   validatorId: ValidatorIdType,
    //   EntryGatingType: uint64,
    //   EntryGatingAddress: arc4.Address,
    //   EntryGatingAssets: FixedArray<uint64, 4>,
    //   GatingAssetMinBalance: uint64,
    //   RewardPerPayout: uint64,
    // ): void {
    callsub changeValidatorRewardInfo
    intc_0 // 1
    return

main_changeValidatorCommissionAddress_route@28:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:307
    // changeValidatorCommissionAddress(validatorId: ValidatorIdType, commissionAddress: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:307
    // changeValidatorCommissionAddress(validatorId: ValidatorIdType, commissionAddress: arc4.Address): void {
    callsub changeValidatorCommissionAddress
    intc_0 // 1
    return

main_changeValidatorNFD_route@27:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:302
    // changeValidatorNFD(validatorId: ValidatorIdType, nfdAppID: uint64, nfdName: arc4.DynamicBytes): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:302
    // changeValidatorNFD(validatorId: ValidatorIdType, nfdAppID: uint64, nfdName: arc4.DynamicBytes): void {
    callsub changeValidatorNFD
    intc_0 // 1
    return

main_changeValidatorSunsetInfo_route@26:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:296
    // changeValidatorSunsetInfo(validatorId: ValidatorIdType, sunsettingOn: uint64, sunsettingTo: ValidatorIdType): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:296
    // changeValidatorSunsetInfo(validatorId: ValidatorIdType, sunsettingOn: uint64, sunsettingTo: ValidatorIdType): void {
    callsub changeValidatorSunsetInfo
    intc_0 // 1
    return

main_changeValidatorManager_route@25:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:291
    // changeValidatorManager(validatorId: ValidatorIdType, manager: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:291
    // changeValidatorManager(validatorId: ValidatorIdType, manager: arc4.Address): void {
    callsub changeValidatorManager
    intc_0 // 1
    return

main_addValidator_route@24:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:278
    // addValidator(nfdName: arc4.DynamicBytes, config: ValidatorConfig): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:278
    // addValidator(nfdName: arc4.DynamicBytes, config: ValidatorConfig): uint64 {
    callsub addValidator
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getNFDRegistryID_route@23:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:274
    // getNFDRegistryID(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 5 // 0x151f7c750000000000000000
    log
    intc_0 // 1
    return

main_getNodePoolAssignments_route@22:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:269
    // getNodePoolAssignments(validatorId: uint64): NodePoolAssignmentConfig {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:269
    // getNodePoolAssignments(validatorId: uint64): NodePoolAssignmentConfig {
    callsub getNodePoolAssignments
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getTokenPayoutRatio_route@21:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:265
    // getTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:265
    // getTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio {
    callsub getTokenPayoutRatio
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getStakedPoolsForAccount_route@20:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:251
    // getStakedPoolsForAccount(staker: arc4.Address): ValidatorPoolKey[] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:251
    // getStakedPoolsForAccount(staker: arc4.Address): ValidatorPoolKey[] {
    callsub getStakedPoolsForAccount
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_doesStakerNeedToPayMBR_route@19:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:247
    // doesStakerNeedToPayMBR(staker: arc4.Address): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:247
    // doesStakerNeedToPayMBR(staker: arc4.Address): boolean {
    callsub doesStakerNeedToPayMBR
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getCurMaxStakePerPool_route@18:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:234
    // getCurMaxStakePerPool(validatorId: ValidatorIdType): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:234
    // getCurMaxStakePerPool(validatorId: ValidatorIdType): uint64 {
    callsub getCurMaxStakePerPool
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getPoolInfo_route@17:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:230
    // getPoolInfo(poolKey: ValidatorPoolKey): PoolInfo {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:230
    // getPoolInfo(poolKey: ValidatorPoolKey): PoolInfo {
    callsub getPoolInfo
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getPoolAppId_route@16:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:225
    // getPoolAppId(validatorId: uint64, poolId: uint64): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:225
    // getPoolAppId(validatorId: uint64, poolId: uint64): uint64 {
    callsub getPoolAppId
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getPools_route@15:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:213
    // getPools(validatorId: ValidatorIdType): PoolInfo[] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:213
    // getPools(validatorId: ValidatorIdType): PoolInfo[] {
    callsub getPools
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getValidatorOwnerAndManager_route@14:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:208
    // getValidatorOwnerAndManager(validatorId: ValidatorIdType): [arc4.Address, arc4.Address] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:208
    // getValidatorOwnerAndManager(validatorId: ValidatorIdType): [arc4.Address, arc4.Address] {
    callsub getValidatorOwnerAndManager
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getValidatorState_route@13:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:204
    // getValidatorState(validatorId: ValidatorIdType): ValidatorCurState {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:204
    // getValidatorState(validatorId: ValidatorIdType): ValidatorCurState {
    callsub getValidatorState
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getValidatorConfig_route@12:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:200
    // getValidatorConfig(validatorId: ValidatorIdType): ValidatorConfig {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:200
    // getValidatorConfig(validatorId: ValidatorIdType): ValidatorConfig {
    callsub getValidatorConfig
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getNumValidators_route@11:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:196
    // getNumValidators(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getNumValidators
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getProtocolConstraints_route@10:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:180
    // getProtocolConstraints(): Constraints {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c75000000000000000100000000000f4240000000000000000000000000000f424000000000000f424000003faa25226000000110d9316ec0000000b5e620f480000000000000000008000000000000000300000000000000c8
    log
    intc_0 // 1
    return

main_getMbrAmounts_route@9:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:171
    // getMbrAmounts(): MbrAmounts {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500000000000632540000000000139b880000000004c64f540000000000012174
    log
    intc_0 // 1
    return

main_gas_route@8:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:169
    // gas(): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_finalizeStakingContract_route@7:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:165
    // finalizeStakingContract(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub finalizeStakingContract
    intc_0 // 1
    return

main_loadStakingContractData_route@6:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:160
    // loadStakingContractData(offset: uint64, data: bytes): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:160
    // loadStakingContractData(offset: uint64, data: bytes): void {
    callsub loadStakingContractData
    intc_0 // 1
    return

main_initStakingContract_route@5:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:156
    // initStakingContract(approvalProgramSize: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:134
    // export class ValidatorRegistry extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:156
    // initStakingContract(approvalProgramSize: uint64): void {
    callsub initStakingContract
    intc_0 // 1
    return

main_createApplication_route@4:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:149
    // createApplication(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub createApplication
    intc_0 // 1
    return

main_updateApplication_route@3:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:143
    // updateApplication(): void {
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub updateApplication
    intc_0 // 1
    return


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.updateApplication() -> void:
updateApplication:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:135
    // stakingPoolApprovalProgram = Box<bytes>({ key: 'poolTemplateApprovalBytes' })
    bytec 7 // "poolTemplateApprovalBytes"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:145
    // this.stakingPoolApprovalProgram.delete()
    box_del
    pop
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:136
    // stakingPoolInitialized = GlobalState<boolean>({ key: 'init' })
    bytec_2 // "init"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:146
    // this.stakingPoolInitialized.value = false
    intc_1 // 0
    app_global_put
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.createApplication() -> void:
createApplication:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:136
    // stakingPoolInitialized = GlobalState<boolean>({ key: 'init' })
    bytec_2 // "init"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:150
    // this.stakingPoolInitialized.value = false
    intc_1 // 0
    app_global_put
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:137
    // numValidators = GlobalState<uint64>({ key: 'numV' })
    bytec_3 // "numV"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:151
    // this.numValidators.value = 0
    intc_1 // 0
    app_global_put
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:138
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    pushbytes "numStakers"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:152
    // this.numStakers.value = 0
    intc_1 // 0
    app_global_put
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:139
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    pushbytes "staked"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:153
    // this.totalAlgoStaked.value = 0
    intc_1 // 0
    app_global_put
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.initStakingContract(approvalProgramSize: uint64) -> void:
initStakingContract:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:156
    // initStakingContract(approvalProgramSize: uint64): void {
    proto 1 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:135
    // stakingPoolApprovalProgram = Box<bytes>({ key: 'poolTemplateApprovalBytes' })
    bytec 7 // "poolTemplateApprovalBytes"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:157
    // this.stakingPoolApprovalProgram.create({ size: approvalProgramSize })
    frame_dig -1
    box_create
    pop
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.loadStakingContractData(offset: uint64, data: bytes) -> void:
loadStakingContractData:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:160
    // loadStakingContractData(offset: uint64, data: bytes): void {
    proto 2 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:136
    // stakingPoolInitialized = GlobalState<boolean>({ key: 'init' })
    intc_1 // 0
    bytec_2 // "init"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:161
    // assert(!this.stakingPoolInitialized.value)
    !
    assert
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.finalizeStakingContract() -> void:
finalizeStakingContract:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:136
    // stakingPoolInitialized = GlobalState<boolean>({ key: 'init' })
    bytec_2 // "init"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:166
    // this.stakingPoolInitialized.value = true
    intc_0 // 1
    app_global_put
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getNumValidators() -> uint64:
getNumValidators:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:137
    // numValidators = GlobalState<uint64>({ key: 'numV' })
    intc_1 // 0
    bytec_3 // "numV"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:197
    // return this.numValidators.value
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getValidatorConfig(validatorId: uint64) -> bytes:
getValidatorConfig:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:200
    // getValidatorConfig(validatorId: ValidatorIdType): ValidatorConfig {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:201
    // return this.validatorList(validatorId).value.config
    frame_dig -1
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:201
    // return this.validatorList(validatorId).value.config
    box_get
    assert // Box must have value
    intc_1 // 0
    intc_2 // 264
    extract3
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getValidatorState(validatorId: uint64) -> bytes:
getValidatorState:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:204
    // getValidatorState(validatorId: ValidatorIdType): ValidatorCurState {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:205
    // return this.validatorList(validatorId).value.state
    frame_dig -1
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:205
    // return this.validatorList(validatorId).value.state
    box_get
    assert // Box must have value
    intc_2 // 264
    pushint 32 // 32
    extract3
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getValidatorOwnerAndManager(validatorId: uint64) -> bytes:
getValidatorOwnerAndManager:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:208
    // getValidatorOwnerAndManager(validatorId: ValidatorIdType): [arc4.Address, arc4.Address] {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:209
    // const validator = clone(this.validatorList(validatorId).value)
    frame_dig -1
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:209
    // const validator = clone(this.validatorList(validatorId).value)
    box_get
    assert // Box must have value
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:210
    // return [validator.config.owner, validator.config.manager]
    intc_1 // 0
    intc_2 // 264
    extract3
    dup
    extract 8 32
    swap
    extract 40 32
    concat
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getPools(validatorId: uint64) -> bytes:
getPools:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:213
    // getPools(validatorId: ValidatorIdType): PoolInfo[] {
    proto 1 1
    intc_1 // 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:214
    // const retData: PoolInfo[] = []
    bytec 4 // 0x0000
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:215
    // const poolSet = clone(this.validatorList(validatorId).value.pools)
    frame_dig -1
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:215
    // const poolSet = clone(this.validatorList(validatorId).value.pools)
    box_get
    assert // Box must have value
    intc 4 // 296
    intc 5 // 576
    extract3
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:216
    // for (let i: uint64 = 0; i < poolSet.length; i += 1) {
    intc_1 // 0

getPools_while_top@1:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:216
    // for (let i: uint64 = 0; i < poolSet.length; i += 1) {
    frame_dig 3
    intc_3 // 24
    <
    bz getPools_block@6
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:217
    // if (poolSet[i].poolAppId === 0) {
    frame_dig 3
    intc_3 // 24
    *
    frame_dig 2
    swap
    intc_3 // 24
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 0
    intc_1 // 0
    extract_uint64
    bz getPools_block@6
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:220
    // retData.push(poolSet[i])
    frame_dig 1
    dup
    frame_dig 0
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:216
    // for (let i: uint64 = 0; i < poolSet.length; i += 1) {
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    b getPools_while_top@1

getPools_block@6:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:222
    // return retData
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getPoolAppId(validatorId: uint64, poolId: uint64) -> uint64:
getPoolAppId:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:225
    // getPoolAppId(validatorId: uint64, poolId: uint64): uint64 {
    proto 2 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:226
    // assert(poolId !== 0 && poolId <= this.validatorList(validatorId).value.pools.length)
    frame_dig -1
    bz getPoolAppId_bool_false@3
    frame_dig -2
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:226
    // assert(poolId !== 0 && poolId <= this.validatorList(validatorId).value.pools.length)
    box_len
    bury 1
    assert // Box must have value
    frame_dig -1
    intc_3 // 24
    <=
    bz getPoolAppId_bool_false@3
    intc_0 // 1

getPoolAppId_bool_merge@4:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:226
    // assert(poolId !== 0 && poolId <= this.validatorList(validatorId).value.pools.length)
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:227
    // return this.validatorList(validatorId).value.pools[poolId - 1].poolAppId
    frame_dig -2
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:227
    // return this.validatorList(validatorId).value.pools[poolId - 1].poolAppId
    box_get
    assert // Box must have value
    intc 4 // 296
    intc 5 // 576
    extract3
    frame_dig -1
    intc_0 // 1
    -
    intc_3 // 24
    *
    intc_3 // 24
    extract3 // on error: index access is out of bounds
    intc_1 // 0
    extract_uint64
    retsub

getPoolAppId_bool_false@3:
    intc_1 // 0
    b getPoolAppId_bool_merge@4


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getPoolInfo(poolKey: bytes) -> bytes:
getPoolInfo:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:230
    // getPoolInfo(poolKey: ValidatorPoolKey): PoolInfo {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:231
    // return this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1]
    frame_dig -1
    intc_1 // 0
    extract_uint64
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:231
    // return this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1]
    box_get
    assert // Box must have value
    intc 4 // 296
    intc 5 // 576
    extract3
    frame_dig -1
    pushint 8 // 8
    extract_uint64
    intc_0 // 1
    -
    intc_3 // 24
    *
    intc_3 // 24
    extract3 // on error: index access is out of bounds
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getCurMaxStakePerPool(validatorId: uint64) -> uint64:
getCurMaxStakePerPool:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:234
    // getCurMaxStakePerPool(validatorId: ValidatorIdType): uint64 {
    proto 1 1
    pushbytes ""
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:235
    // const numPools: uint64 = this.validatorList(validatorId).value.state.numPools
    frame_dig -1
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:235
    // const numPools: uint64 = this.validatorList(validatorId).value.state.numPools
    box_get
    assert // Box must have value
    dup
    intc_2 // 264
    pushint 32 // 32
    extract3
    intc_1 // 0
    extract_uint64
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:433
    // return (online * MAX_VALIDATOR_HARD_PCT_OF_ONLINE_1DECIMAL) / 1000
    pushint 300000000000000 // 300000000000000
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:236
    // const hardMaxDividedBetweenPools: uint64 = this.maxAllowedStake() / numPools
    swap
    /
    swap
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:237
    // let maxPerPool: uint64 = this.validatorList(validatorId).value.config.maxAlgoPerPool
    intc_1 // 0
    intc_2 // 264
    extract3
    pushint 232 // 232
    extract_uint64
    dup
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:238
    // if (maxPerPool === 0) {
    bnz getCurMaxStakePerPool_after_if_else@2
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:437
    // return 70_000_000_000_000 // 70m ALGO in microAlgo
    pushint 70000000000000 // 70000000000000
    frame_bury 2

getCurMaxStakePerPool_after_if_else@2:
    frame_dig 2
    dup
    frame_bury 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:241
    // if (hardMaxDividedBetweenPools < maxPerPool) {
    frame_dig 1
    >
    bz getCurMaxStakePerPool_after_if_else@4
    frame_dig 1
    frame_bury 0

getCurMaxStakePerPool_after_if_else@4:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:244
    // return maxPerPool
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.doesStakerNeedToPayMBR(staker: bytes) -> uint64:
doesStakerNeedToPayMBR:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:247
    // doesStakerNeedToPayMBR(staker: arc4.Address): boolean {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:141
    // stakerPoolSet = BoxMap<arc4.Address, FixedArray<ValidatorPoolKey, typeof MAX_POOLS_PER_STAKER>>({ keyPrefix: 'sps' })
    bytec 8 // "sps"
    frame_dig -1
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:248
    // return !this.stakerPoolSet(staker).exists
    box_len
    bury 1
    !
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getStakedPoolsForAccount(staker: bytes) -> bytes:
getStakedPoolsForAccount:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:251
    // getStakedPoolsForAccount(staker: arc4.Address): ValidatorPoolKey[] {
    proto 1 1
    intc_1 // 0
    dupn 3
    pushbytes ""
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:141
    // stakerPoolSet = BoxMap<arc4.Address, FixedArray<ValidatorPoolKey, typeof MAX_POOLS_PER_STAKER>>({ keyPrefix: 'sps' })
    bytec 8 // "sps"
    frame_dig -1
    concat
    dup
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:252
    // if (!this.stakerPoolSet(staker).exists) {
    box_len
    bury 1
    bnz getStakedPoolsForAccount_after_if_else@2
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:253
    // return []
    bytec 4 // 0x0000
    frame_bury 0
    retsub

getStakedPoolsForAccount_after_if_else@2:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:255
    // const retData: ValidatorPoolKey[] = []
    bytec 4 // 0x0000
    frame_bury 2
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:256
    // const poolSet = clone(this.stakerPoolSet(staker).value)
    frame_dig 5
    box_get
    swap
    frame_bury 1
    assert // Box must have value
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:257
    // for (let i: uint64 = 0; i < poolSet.length; i += 1) {
    intc_1 // 0
    frame_bury 4

getStakedPoolsForAccount_while_top@3:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:257
    // for (let i: uint64 = 0; i < poolSet.length; i += 1) {
    frame_dig 4
    pushint 6 // 6
    <
    bz getStakedPoolsForAccount_after_while@7
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:258
    // if (poolSet[i].id !== 0) {
    frame_dig 4
    intc_3 // 24
    *
    frame_dig 1
    swap
    intc_3 // 24
    extract3 // on error: index access is out of bounds
    dup
    frame_bury 0
    intc_1 // 0
    extract_uint64
    frame_dig 2
    frame_bury 3
    bz getStakedPoolsForAccount_after_if_else@6
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:259
    // retData.push(poolSet[i])
    frame_dig 2
    dup
    frame_dig 0
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury 3

getStakedPoolsForAccount_after_if_else@6:
    frame_dig 3
    frame_bury 2
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:257
    // for (let i: uint64 = 0; i < poolSet.length; i += 1) {
    frame_dig 4
    intc_0 // 1
    +
    frame_bury 4
    b getStakedPoolsForAccount_while_top@3

getStakedPoolsForAccount_after_while@7:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:262
    // return retData
    frame_dig 2
    frame_bury 0
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getTokenPayoutRatio(validatorId: uint64) -> bytes:
getTokenPayoutRatio:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:265
    // getTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:266
    // return this.validatorList(validatorId).value.tokenPayoutRatio
    frame_dig -1
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:266
    // return this.validatorList(validatorId).value.tokenPayoutRatio
    box_get
    assert // Box must have value
    pushints 872 200 // 872, 200
    extract3
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.getNodePoolAssignments(validatorId: uint64) -> bytes:
getNodePoolAssignments:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:269
    // getNodePoolAssignments(validatorId: uint64): NodePoolAssignmentConfig {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:270
    // assert(this.validatorList(validatorId).exists)
    frame_dig -1
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:270
    // assert(this.validatorList(validatorId).exists)
    dup
    box_len
    bury 1
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:271
    // return this.validatorList(validatorId).value.nodePoolAssignments
    box_get
    pop
    pushint 1072 // 1072
    intc 6 // 192
    extract3
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.addValidator(nfdName: bytes, config: bytes) -> uint64:
addValidator:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:278
    // addValidator(nfdName: arc4.DynamicBytes, config: ValidatorConfig): uint64 {
    proto 2 1
    pushbytes ""
    dup
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:394
    // assert(config.entryGatingType >= GATING_TYPE_NONE && config.entryGatingType <= GATING_TYPE_CONST_MAX)
    frame_dig -1
    pushint 80 // 80
    extract_uint64
    pushint 4 // 4
    <=
    bz addValidator_bool_false@4
    intc_0 // 1

addValidator_bool_merge@5:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:394
    // assert(config.entryGatingType >= GATING_TYPE_NONE && config.entryGatingType <= GATING_TYPE_CONST_MAX)
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:395
    // assert(config.epochRoundLength >= MIN_EPOCH_LENGTH && config.epochRoundLength <= MAX_EPOCH_LENGTH)
    frame_dig -1
    pushint 176 // 176
    extract_uint64
    dup
    frame_bury 0
    bz addValidator_bool_false@8
    frame_dig 0
    intc 7 // 1000000
    <=
    bz addValidator_bool_false@8
    intc_0 // 1

addValidator_bool_merge@9:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:395
    // assert(config.epochRoundLength >= MIN_EPOCH_LENGTH && config.epochRoundLength <= MAX_EPOCH_LENGTH)
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:396
    // assert(config.percentToValidator >= MIN_PCT_TO_VALIDATOR && config.percentToValidator <= MAX_PCT_TO_VALIDATOR)
    frame_dig -1
    pushint 184 // 184
    extract_uint64
    intc 7 // 1000000
    <=
    bz addValidator_bool_false@12
    intc_0 // 1

addValidator_bool_merge@13:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:396
    // assert(config.percentToValidator >= MIN_PCT_TO_VALIDATOR && config.percentToValidator <= MAX_PCT_TO_VALIDATOR)
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:397
    // assert(config.minEntryStake >= MIN_ALGO_STAKE_PER_POOL)
    frame_dig -1
    pushint 224 // 224
    extract_uint64
    intc 7 // 1000000
    >=
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:398
    // assert(config.poolsPerNode > 0 && config.poolsPerNode <= MAX_POOLS_PER_NODE)
    frame_dig -1
    pushint 240 // 240
    extract_uint64
    dup
    frame_bury 1
    bz addValidator_bool_false@16
    frame_dig 1
    pushint 3 // 3
    <=
    bz addValidator_bool_false@16
    intc_0 // 1

addValidator_bool_merge@17:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:398
    // assert(config.poolsPerNode > 0 && config.poolsPerNode <= MAX_POOLS_PER_NODE)
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:280
    // assert(Txn.sender.bytes === config.owner.bytes)
    txn Sender
    frame_dig -1
    extract 8 32
    ==
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:137
    // numValidators = GlobalState<uint64>({ key: 'numV' })
    intc_1 // 0
    bytec_3 // "numV"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:282
    // const validatorId: uint64 = this.numValidators.value + 1
    intc_0 // 1
    +
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:137
    // numValidators = GlobalState<uint64>({ key: 'numV' })
    bytec_3 // "numV"
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:283
    // this.numValidators.value = validatorId
    dig 1
    app_global_put
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:285
    // this.validatorList(validatorId).create()
    dup
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    dig 1
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:285
    // this.validatorList(validatorId).create()
    dup
    pushint 1264 // 1264
    box_create
    pop
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:286
    // this.validatorList(validatorId).value.config = clone(config)
    dup
    intc_1 // 0
    frame_dig -1
    box_replace
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:287
    // this.validatorList(validatorId).value.config.id = validatorId
    intc_1 // 0
    uncover 2
    box_replace
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:289
    // return validatorId
    frame_bury 0
    retsub

addValidator_bool_false@16:
    intc_1 // 0
    b addValidator_bool_merge@17

addValidator_bool_false@12:
    intc_1 // 0
    b addValidator_bool_merge@13

addValidator_bool_false@8:
    intc_1 // 0
    b addValidator_bool_merge@9

addValidator_bool_false@4:
    intc_1 // 0
    b addValidator_bool_merge@5


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.changeValidatorManager(validatorId: uint64, manager: bytes) -> void:
changeValidatorManager:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:291
    // changeValidatorManager(validatorId: ValidatorIdType, manager: arc4.Address): void {
    proto 2 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:292
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    txn Sender
    frame_dig -2
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:292
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    dup
    box_get
    assert // Box must have value
    intc_1 // 0
    intc_2 // 264
    extract3
    extract 8 32
    uncover 2
    ==
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:293
    // this.validatorList(validatorId).value.config.manager = manager
    pushint 40 // 40
    frame_dig -1
    box_replace
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.changeValidatorSunsetInfo(validatorId: uint64, sunsettingOn: uint64, sunsettingTo: uint64) -> void:
changeValidatorSunsetInfo:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:296
    // changeValidatorSunsetInfo(validatorId: ValidatorIdType, sunsettingOn: uint64, sunsettingTo: ValidatorIdType): void {
    proto 3 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:297
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    txn Sender
    frame_dig -3
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:297
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    dup
    box_get
    assert // Box must have value
    intc_1 // 0
    intc_2 // 264
    extract3
    extract 8 32
    uncover 2
    ==
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:298
    // this.validatorList(validatorId).value.config.sunsettingOn = sunsettingOn
    frame_dig -2
    itob
    dig 1
    pushint 248 // 248
    uncover 2
    box_replace
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:299
    // this.validatorList(validatorId).value.config.sunsettingTo = sunsettingTo
    frame_dig -1
    itob
    pushint 256 // 256
    swap
    box_replace
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.changeValidatorNFD(validatorId: uint64, nfdAppID: uint64, nfdName: bytes) -> void:
changeValidatorNFD:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:302
    // changeValidatorNFD(validatorId: ValidatorIdType, nfdAppID: uint64, nfdName: arc4.DynamicBytes): void {
    proto 3 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:303
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    txn Sender
    frame_dig -3
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:303
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    dup
    box_get
    assert // Box must have value
    intc_1 // 0
    intc_2 // 264
    extract3
    extract 8 32
    uncover 2
    ==
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:304
    // this.validatorList(validatorId).value.config.nfdForInfo = nfdAppID
    frame_dig -2
    itob
    pushint 72 // 72
    swap
    box_replace
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.changeValidatorCommissionAddress(validatorId: uint64, commissionAddress: bytes) -> void:
changeValidatorCommissionAddress:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:307
    // changeValidatorCommissionAddress(validatorId: ValidatorIdType, commissionAddress: arc4.Address): void {
    proto 2 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:308
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    txn Sender
    frame_dig -2
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:308
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    dup
    box_get
    assert // Box must have value
    intc_1 // 0
    intc_2 // 264
    extract3
    extract 8 32
    uncover 2
    ==
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:309
    // this.validatorList(validatorId).value.config.validatorCommissionAddress = commissionAddress
    intc 6 // 192
    frame_dig -1
    box_replace
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.changeValidatorRewardInfo(validatorId: uint64, EntryGatingType: uint64, EntryGatingAddress: bytes, EntryGatingAssets: bytes, GatingAssetMinBalance: uint64, RewardPerPayout: uint64) -> void:
changeValidatorRewardInfo:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:312-319
    // changeValidatorRewardInfo(
    //   validatorId: ValidatorIdType,
    //   EntryGatingType: uint64,
    //   EntryGatingAddress: arc4.Address,
    //   EntryGatingAssets: FixedArray<uint64, 4>,
    //   GatingAssetMinBalance: uint64,
    //   RewardPerPayout: uint64,
    // ): void {
    proto 6 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:320
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    txn Sender
    frame_dig -6
    itob
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:140
    // validatorList = BoxMap<ValidatorIdType, ValidatorInfo>({ keyPrefix: 'v' })
    bytec_0 // "v"
    swap
    concat
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:320
    // assert(Txn.sender.bytes === this.validatorList(validatorId).value.config.owner.bytes)
    dup
    box_get
    assert // Box must have value
    intc_1 // 0
    intc_2 // 264
    extract3
    extract 8 32
    uncover 2
    ==
    assert
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:321
    // this.validatorList(validatorId).value.config.entryGatingType = EntryGatingType
    frame_dig -5
    itob
    dig 1
    pushint 80 // 80
    uncover 2
    box_replace
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:322
    // this.validatorList(validatorId).value.config.entryGatingAddress = EntryGatingAddress
    dup
    pushint 88 // 88
    frame_dig -4
    box_replace
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:323
    // this.validatorList(validatorId).value.config.entryGatingAssets = clone(EntryGatingAssets)
    dup
    pushint 120 // 120
    frame_dig -3
    box_replace
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:324
    // this.validatorList(validatorId).value.config.gatingAssetMinBalance = GatingAssetMinBalance
    frame_dig -2
    itob
    dig 1
    pushint 152 // 152
    uncover 2
    box_replace
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:325
    // this.validatorList(validatorId).value.config.rewardPerPayout = RewardPerPayout
    frame_dig -1
    itob
    pushint 168 // 168
    swap
    box_replace
    retsub


// smart_contracts/reti_validator_registry/validatorRegistry.algo.ts::ValidatorRegistry.setTokenPayoutRatio(validatorId: uint64) -> bytes:
setTokenPayoutRatio:
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:344
    // setTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio {
    proto 1 1
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:346
    // poolPctOfWhole: new FixedArray<uint64, 24>(),
    intc 6 // 192
    bzero
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:347
    // updatedForPayout: 0,
    intc_1 // 0
    // smart_contracts/reti_validator_registry/validatorRegistry.algo.ts:345-348
    // return {
    //   poolPctOfWhole: new FixedArray<uint64, 24>(),
    //   updatedForPayout: 0,
    // }
    itob
    concat
    retsub
