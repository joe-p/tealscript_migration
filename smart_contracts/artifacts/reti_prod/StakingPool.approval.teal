#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 64 16 200 157 300 2100000 1000000 30857 TMPL_NFD_REGISTRY_APP_ID
    bytecblock "stakers" "creatorApp" 0x151f7c75 "validatorId" "poolId" "staked" "roundsPerDay" "stakeAccumulator" 0x0002 "binRoundStart" "numStakers" "rewardAccumulator" "ewma" 0x75aff61d 0x64 "minEntryStake" "lastPayout" "epochNumber" 0x000100000000000f4240 0x0001 0x0c2245e1 0x068101 0x00000000000000000000000000000001 0x00000000000000000000000000000000 0xa2dc51b5 0x572767d1 0x4df8d86e 0x0003
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn NumAppArgs
    bz main_after_if_else@20
    pushbytess 0x59e90aa6 0x3172ca9d 0x47cfcc04 0xf9c70cbd 0x421b5abe 0xf5892d56 0x5cfbb057 0x63f3f28b 0x86a3725c 0xefc2608d 0x9cee2e40 0x51ef3b21 0xa24e2717 // method "createApplication(uint64,uint64,uint64,uint64)void", method "gas()void", method "initStorage(pay)void", method "addStake(pay,address)uint64", method "removeStake(address,uint64)void", method "claimTokens()void", method "getStakerInfo(address)(address,uint64,uint64,uint64,uint64)", method "payTokenReward(address,uint64,uint64)void", method "updateAlgodVer(string)void", method "epochBalanceUpdate()void", method "goOnline(pay,byte[32],byte[32],byte[64],uint64,uint64,uint64)void", method "goOffline()void", method "linkToNFD(uint64,string)void"
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_gas_route@4 main_initStorage_route@5 main_addStake_route@6 main_removeStake_route@7 main_claimTokens_route@8 main_getStakerInfo_route@9 main_payTokenReward_route@10 main_updateAlgodVer_route@11 main_epochBalanceUpdate_route@12 main_goOnline_route@13 main_goOffline_route@14 main_linkToNFD_route@15 main_proxiedSetTokenPayoutRatio_route@16

main_after_if_else@20:
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    intc_0 // 0
    return

main_proxiedSetTokenPayoutRatio_route@16:
    // smart_contracts/reti_prod/stakingPool.algo.ts:979
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:979
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    callsub proxiedSetTokenPayoutRatio
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_linkToNFD_route@15:
    // smart_contracts/reti_prod/stakingPool.algo.ts:956
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:956
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    callsub linkToNFD
    intc_1 // 1
    return

main_goOffline_route@14:
    // smart_contracts/reti_prod/stakingPool.algo.ts:943
    // goOffline(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub goOffline
    intc_1 // 1
    return

main_goOnline_route@13:
    // smart_contracts/reti_prod/stakingPool.algo.ts:913-921
    // goOnline(
    //   feePayment: gtxn.PaymentTxn,
    //   votePK: bytes<32>,
    //   selectionPK: bytes<32>,
    //   stateProofPK: bytes<64>,
    //   voteFirst: uint64,
    //   voteLast: uint64,
    //   voteKeyDilution: uint64,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // smart_contracts/reti_prod/stakingPool.algo.ts:913-921
    // goOnline(
    //   feePayment: gtxn.PaymentTxn,
    //   votePK: bytes<32>,
    //   selectionPK: bytes<32>,
    //   stateProofPK: bytes<64>,
    //   voteFirst: uint64,
    //   voteLast: uint64,
    //   voteKeyDilution: uint64,
    // ): void {
    callsub goOnline
    intc_1 // 1
    return

main_epochBalanceUpdate_route@12:
    // smart_contracts/reti_prod/stakingPool.algo.ts:544
    // epochBalanceUpdate(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub epochBalanceUpdate
    intc_1 // 1
    return

main_updateAlgodVer_route@11:
    // smart_contracts/reti_prod/stakingPool.algo.ts:531
    // updateAlgodVer(algodVer: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:531
    // updateAlgodVer(algodVer: string): void {
    callsub updateAlgodVer
    intc_1 // 1
    return

main_payTokenReward_route@10:
    // smart_contracts/reti_prod/stakingPool.algo.ts:503
    // payTokenReward(staker: Address, rewardToken: uint64, amountToSend: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/reti_prod/stakingPool.algo.ts:503
    // payTokenReward(staker: Address, rewardToken: uint64, amountToSend: uint64): void {
    callsub payTokenReward
    intc_1 // 1
    return

main_getStakerInfo_route@9:
    // smart_contracts/reti_prod/stakingPool.algo.ts:482
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:482
    // @abimethod({ readonly: true })
    callsub getStakerInfo
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_claimTokens_route@8:
    // smart_contracts/reti_prod/stakingPool.algo.ts:413
    // claimTokens(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimTokens
    intc_1 // 1
    return

main_removeStake_route@7:
    // smart_contracts/reti_prod/stakingPool.algo.ts:301
    // removeStake(staker: Address, amountToUnstake: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/reti_prod/stakingPool.algo.ts:301
    // removeStake(staker: Address, amountToUnstake: uint64): void {
    callsub removeStake
    intc_1 // 1
    return

main_addStake_route@6:
    // smart_contracts/reti_prod/stakingPool.algo.ts:216
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Address): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:216
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Address): uint64 {
    callsub addStake
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initStorage_route@5:
    // smart_contracts/reti_prod/stakingPool.algo.ts:174
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/reti_prod/stakingPool.algo.ts:174
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    callsub initStorage
    intc_1 // 1
    return

main_gas_route@4:
    // smart_contracts/reti_prod/stakingPool.algo.ts:158
    // gas(): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/reti_prod/stakingPool.algo.ts:129
    // createApplication(creatingContractId: Application, validatorId: uint64, poolId: uint64, minEntryStake: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/reti_prod/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/reti_prod/stakingPool.algo.ts:129
    // createApplication(creatingContractId: Application, validatorId: uint64, poolId: uint64, minEntryStake: uint64): void {
    callsub createApplication
    intc_1 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@7
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 21 // 0x068101
    itxn_field ApprovalProgram
    bytec 21 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@6:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_after_while@7:
    retsub


// smart_contracts/reti_prod/utils.algo.ts::wideRatio(numeratorFactors: bytes, denominatorFactors: bytes) -> uint64, bytes, bytes:
wideRatio:
    // smart_contracts/reti_prod/utils.algo.ts:4
    // export function wideRatio(numeratorFactors: uint64[], denominatorFactors: uint64[]): uint64 {
    proto 2 3
    intc_0 // 0
    pushbytes ""
    dup
    // smart_contracts/reti_prod/utils.algo.ts:5
    // let numerator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    // smart_contracts/reti_prod/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_0 // 0

wideRatio_for_header@1:
    // smart_contracts/reti_prod/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig 5
    frame_dig 4
    <
    bz wideRatio_after_for@4
    frame_dig -2
    extract 2 0
    frame_dig 5
    dup
    cover 2
    pushint 8 // 8
    *
    extract_uint64
    // smart_contracts/reti_prod/utils.algo.ts:7
    // numerator = new Uint128(BigUint(factor) * numerator.native)
    itob
    frame_dig 3
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 3
    intc_1 // 1
    +
    frame_bury 5
    b wideRatio_for_header@1

wideRatio_after_for@4:
    // smart_contracts/reti_prod/utils.algo.ts:10
    // let denominator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    frame_bury 0
    // smart_contracts/reti_prod/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 1
    intc_0 // 0
    frame_bury 2

wideRatio_for_header@5:
    // smart_contracts/reti_prod/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig 2
    frame_dig 1
    <
    bz wideRatio_after_for@8
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 8 // 8
    *
    extract_uint64
    // smart_contracts/reti_prod/utils.algo.ts:12
    // denominator = new Uint128(BigUint(factor) * denominator.native)
    itob
    frame_dig 0
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 2
    b wideRatio_for_header@5

wideRatio_after_for@8:
    // smart_contracts/reti_prod/utils.algo.ts:15
    // const ratio: biguint = numerator.native / denominator.native
    frame_dig 3
    frame_dig 0
    b/
    // smart_contracts/reti_prod/utils.algo.ts:16
    // return new Uint64(ratio).native
    dup
    len
    pushint 8 // 8
    <=
    assert // overflow
    pushint 8 // 8
    bzero
    b|
    btoi
    frame_dig -2
    frame_dig -1
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.createApplication(creatingContractId: uint64, validatorId: uint64, poolId: uint64, minEntryStake: uint64) -> void:
createApplication:
    // smart_contracts/reti_prod/stakingPool.algo.ts:129
    // createApplication(creatingContractId: Application, validatorId: uint64, poolId: uint64, minEntryStake: uint64): void {
    proto 4 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:130
    // if (creatingContractId === Application(0)) {
    frame_dig -4
    bnz createApplication_else_body@2
    // smart_contracts/reti_prod/stakingPool.algo.ts:132
    // assert(validatorId === 0)
    frame_dig -3
    !
    assert
    // smart_contracts/reti_prod/stakingPool.algo.ts:133
    // assert(poolId === 0)
    frame_dig -2
    !
    assert

createApplication_after_if_else@3:
    // smart_contracts/reti_prod/stakingPool.algo.ts:138
    // assert(minEntryStake >= MIN_ALGO_STAKE_PER_POOL, 'staking pool must have minimum entry of 1 algo')
    frame_dig -1
    intc 8 // 1000000
    >=
    assert // staking pool must have minimum entry of 1 algo
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:139
    // this.creatingValidatorContractAppId.value = creatingContractId.id
    frame_dig -4
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:140
    // this.validatorId.value = validatorId
    frame_dig -3
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:141
    // this.poolId.value = poolId
    frame_dig -2
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:142
    // this.numStakers.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:143
    // this.totalAlgoStaked.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:88
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // smart_contracts/reti_prod/stakingPool.algo.ts:144
    // this.minEntryStake.value = minEntryStake
    frame_dig -1
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:91
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // smart_contracts/reti_prod/stakingPool.algo.ts:145
    // this.lastPayout.value = Global.round // set to init block to establish baseline
    global Round
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:94
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // smart_contracts/reti_prod/stakingPool.algo.ts:146
    // this.epochNumber.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:148
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // smart_contracts/reti_prod/stakingPool.algo.ts:149
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    global Round
    dup
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:149
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // smart_contracts/reti_prod/stakingPool.algo.ts:149
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:150
    // this.stakeAccumulator.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:151
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // smart_contracts/reti_prod/stakingPool.algo.ts:152
    // this.weightedMovingAverage.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    retsub

createApplication_else_body@2:
    // smart_contracts/reti_prod/stakingPool.algo.ts:135
    // assert(validatorId !== 0)
    frame_dig -3
    assert
    // smart_contracts/reti_prod/stakingPool.algo.ts:136
    // assert(poolId !== 0)
    frame_dig -2
    assert
    b createApplication_after_if_else@3


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.initStorage(mbrPayment: uint64) -> void:
initStorage:
    // smart_contracts/reti_prod/stakingPool.algo.ts:174
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    proto 1 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:175
    // assert(!this.stakers.exists, 'staking pool already initialized')
    box_len
    bury 1
    !
    assert // staking pool already initialized
    // smart_contracts/reti_prod/stakingPool.algo.ts:178-181
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:179
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:179
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:180
    // args: [this.validatorId.value],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:180
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:178-181
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc 5 // 157
    // smart_contracts/reti_prod/stakingPool.algo.ts:183
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // smart_contracts/reti_prod/stakingPool.algo.ts:184
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    bz initStorage_bool_false@4
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:184
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_bool_false@4
    intc_1 // 1

initStorage_bool_merge@5:
    // smart_contracts/reti_prod/stakingPool.algo.ts:184
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    pushint 100000 // 100000
    *
    // smart_contracts/reti_prod/stakingPool.algo.ts:186-188
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // extraMBR +
    // this.costForBoxStorage(7 /* 'stakers' name */ + arc4EncodedLength<StakedInfo>() * MAX_STAKERS_PER_POOL)
    pushint 5225300 // 5225300
    +
    // smart_contracts/reti_prod/stakingPool.algo.ts:191
    // assertMatch(mbrPayment, { receiver: Global.currentApplicationAddress, amount: PoolInitMbr })
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    frame_dig -1
    gtxns Amount
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:192
    // this.stakers.create()
    pushint 12800 // 12800
    box_create
    pop
    // smart_contracts/reti_prod/stakingPool.algo.ts:194
    // if (isTokenEligible && this.poolId.value === 1) {
    frame_dig 0
    bz initStorage_after_if_else@9
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:194
    // if (isTokenEligible && this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_after_if_else@9
    // smart_contracts/reti_prod/stakingPool.algo.ts:196-202
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:199
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/reti_prod/stakingPool.algo.ts:200
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig 0
    itxn_field XferAsset
    // smart_contracts/reti_prod/stakingPool.algo.ts:196-201
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:196-202
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    //   .submit()
    itxn_submit

initStorage_after_if_else@9:
    retsub

initStorage_bool_false@4:
    intc_0 // 0
    b initStorage_bool_merge@5


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.addStake(stakedAmountPayment: uint64, staker: bytes) -> uint64:
addStake:
    // smart_contracts/reti_prod/stakingPool.algo.ts:216
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Address): uint64 {
    proto 2 1
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:217
    // assert(this.stakers.exists, 'staking pool must be initialized first')
    box_len
    bury 1
    assert // staking pool must be initialized first
    // smart_contracts/reti_prod/stakingPool.algo.ts:221
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    txn Sender
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:221
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/reti_prod/stakingPool.algo.ts:220-223
    // assert(
    //   Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    //   'stake can only be added via the validator contract',
    // )
    assert // stake can only be added via the validator contract
    // smart_contracts/reti_prod/stakingPool.algo.ts:224
    // assert(staker.native !== Global.zeroAddress)
    frame_dig -1
    global ZeroAddress
    !=
    assert
    // smart_contracts/reti_prod/stakingPool.algo.ts:227
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // smart_contracts/reti_prod/stakingPool.algo.ts:231-235
    // assertMatch(stakedAmountPayment, {
    //   sender: Application(this.creatingValidatorContractAppId.value).address,
    //   receiver: Global.currentApplicationAddress,
    //   amount: stakedAmountPayment.amount,
    // })
    frame_dig -2
    gtxns Sender
    // smart_contracts/reti_prod/stakingPool.algo.ts:232
    // sender: Application(this.creatingValidatorContractAppId.value).address,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:232
    // sender: Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:231-235
    // assertMatch(stakedAmountPayment, {
    //   sender: Application(this.creatingValidatorContractAppId.value).address,
    //   receiver: Global.currentApplicationAddress,
    //   amount: stakedAmountPayment.amount,
    // })
    ==
    frame_dig -2
    gtxns Receiver
    // smart_contracts/reti_prod/stakingPool.algo.ts:233
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/reti_prod/stakingPool.algo.ts:231-235
    // assertMatch(stakedAmountPayment, {
    //   sender: Application(this.creatingValidatorContractAppId.value).address,
    //   receiver: Global.currentApplicationAddress,
    //   amount: stakedAmountPayment.amount,
    // })
    ==
    &&
    frame_dig -2
    gtxns Amount
    dup
    uncover 2
    intc_1 // 1
    &&
    assert // assert target is match for conditions
    // smart_contracts/reti_prod/stakingPool.algo.ts:240
    // const entryRound: uint64 = Global.round + ALGORAND_STAKING_BLOCK_DELAY
    global Round
    pushint 320 // 320
    +
    swap
    // smart_contracts/reti_prod/stakingPool.algo.ts:241
    // let firstEmpty: uint64 = 0
    intc_0 // 0
    swap
    // smart_contracts/reti_prod/stakingPool.algo.ts:243
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:243
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    +
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:243
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:245
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // smart_contracts/reti_prod/stakingPool.algo.ts:245
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:245
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:247
    // this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:247
    // this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    itob
    dup
    cover 3
    uncover 2
    itob
    b*
    b+
    // smart_contracts/reti_prod/stakingPool.algo.ts:246-248
    // this.stakeAccumulator.value = new Uint128(
    //   this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:246-248
    // this.stakeAccumulator.value = new Uint128(
    //   this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:251
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

addStake_while_top@1:
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:251
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 8
    intc 4 // 200
    <
    bz addStake_after_while@8
    // smart_contracts/reti_prod/stakingPool.algo.ts:252
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/reti_prod/stakingPool.algo.ts:253
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 8
    intc_2 // 64
    *
    dup
    frame_bury 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:253
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:253-254
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    dup
    frame_bury 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:254
    // if (cmpStaker.account === staker) {
    frame_dig -1
    ==
    bz addStake_after_if_else@4
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:253
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 2
    dup
    cover 2
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:256
    // cmpStaker.balance += stakedAmountPayment.amount
    extract_uint64
    frame_dig 4
    +
    itob
    frame_dig 1
    swap
    replace2 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:257
    // cmpStaker.entryRound = entryRound
    frame_dig 5
    dup
    cover 2
    itob
    replace2 56
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:260
    // this.stakers.value[i] = clone(cmpStaker)
    uncover 3
    uncover 2
    box_replace
    // smart_contracts/reti_prod/stakingPool.algo.ts:262
    // return entryRound
    frame_bury 0
    retsub

addStake_after_if_else@4:
    frame_dig 6
    dup
    frame_bury 3
    // smart_contracts/reti_prod/stakingPool.algo.ts:264
    // if (firstEmpty === 0 && cmpStaker.account.native === Global.zeroAddress) {
    bnz addStake_after_if_else@7
    frame_dig 0
    global ZeroAddress
    ==
    frame_dig 6
    frame_bury 3
    bz addStake_after_if_else@7
    // smart_contracts/reti_prod/stakingPool.algo.ts:265
    // firstEmpty = i + 1
    frame_dig 8
    intc_1 // 1
    +
    frame_bury 3

addStake_after_if_else@7:
    frame_dig 3
    frame_bury 6
    // smart_contracts/reti_prod/stakingPool.algo.ts:251
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 8
    intc_1 // 1
    +
    frame_bury 8
    b addStake_while_top@1

addStake_after_while@8:
    // smart_contracts/reti_prod/stakingPool.algo.ts:269
    // if (firstEmpty === 0) {
    frame_dig 6
    dup
    !
    !
    assert // Staking pool full
    // smart_contracts/reti_prod/stakingPool.algo.ts:276
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:88
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // smart_contracts/reti_prod/stakingPool.algo.ts:276
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 4
    <=
    assert // must stake at least the minimum for this pool
    // smart_contracts/reti_prod/stakingPool.algo.ts:278
    // assert(this.stakers.value[firstEmpty - 1].account.native === Global.zeroAddress)
    intc_1 // 1
    -
    intc_2 // 64
    *
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:278
    // assert(this.stakers.value[firstEmpty - 1].account.native === Global.zeroAddress)
    dig 1
    intc_2 // 64
    box_extract
    extract 0 32
    global ZeroAddress
    ==
    assert
    // smart_contracts/reti_prod/stakingPool.algo.ts:279-285
    // this.stakers.value[firstEmpty - 1] = {
    //   account: staker,
    //   balance: stakedAmountPayment.amount,
    //   totalRewarded: 0,
    //   rewardTokenBalance: 0,
    //   entryRound: entryRound,
    // }
    frame_dig -1
    frame_dig 7
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:282
    // totalRewarded: 0,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:279-285
    // this.stakers.value[firstEmpty - 1] = {
    //   account: staker,
    //   balance: stakedAmountPayment.amount,
    //   totalRewarded: 0,
    //   rewardTokenBalance: 0,
    //   entryRound: entryRound,
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    frame_dig 5
    dup
    cover 2
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:279-285
    // this.stakers.value[firstEmpty - 1] = {
    //   account: staker,
    //   balance: stakedAmountPayment.amount,
    //   totalRewarded: 0,
    //   rewardTokenBalance: 0,
    //   entryRound: entryRound,
    // }
    uncover 3
    uncover 2
    box_replace
    // smart_contracts/reti_prod/stakingPool.algo.ts:286
    // this.numStakers.value += 1
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:286
    // this.numStakers.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/reti_prod/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:286
    // this.numStakers.value += 1
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:287
    // return entryRound
    frame_bury 0
    retsub


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.removeStake(staker: bytes, amountToUnstake: uint64) -> void:
removeStake:
    // smart_contracts/reti_prod/stakingPool.algo.ts:301
    // removeStake(staker: Address, amountToUnstake: uint64): void {
    proto 2 0
    intc_0 // 0
    dup
    pushbytes ""
    dupn 6
    // smart_contracts/reti_prod/stakingPool.algo.ts:304
    // if (staker.native !== Txn.sender) {
    frame_dig -2
    txn Sender
    !=
    bz removeStake_after_if_else@2
    // smart_contracts/reti_prod/stakingPool.algo.ts:306
    // this.isOwnerOrManagerCaller(),
    callsub isOwnerOrManagerCaller
    // smart_contracts/reti_prod/stakingPool.algo.ts:305-308
    // assert(
    //   this.isOwnerOrManagerCaller(),
    //   'If staker is not sender in removeStake call, then sender MUST be owner or manager of validator',
    // )
    assert // If staker is not sender in removeStake call, then sender MUST be owner or manager of validator

removeStake_after_if_else@2:
    // smart_contracts/reti_prod/stakingPool.algo.ts:311
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // smart_contracts/reti_prod/stakingPool.algo.ts:313
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    frame_bury 6

removeStake_while_top@3:
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:313
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 6
    dup
    intc 4 // 200
    <
    assert // account not found
    // smart_contracts/reti_prod/stakingPool.algo.ts:314
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/reti_prod/stakingPool.algo.ts:315
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    frame_bury 5
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:315
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:315-316
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:316
    // if (cmpStaker.account === staker) {
    frame_dig -2
    ==
    bz removeStake_after_if_else@25
    frame_dig -1
    frame_bury 4
    // smart_contracts/reti_prod/stakingPool.algo.ts:317
    // if (amountToUnstake === 0) {
    frame_dig -1
    bnz removeStake_after_if_else@7
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:315
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 5
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:319
    // amountToUnstake = cmpStaker.balance
    extract_uint64
    dup
    frame_bury -1
    frame_bury 4

removeStake_after_if_else@7:
    frame_dig 4
    frame_bury -1
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:315
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 5
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:321
    // if (cmpStaker.balance < amountToUnstake) {
    extract_uint64
    dup
    frame_dig -1
    <
    !
    assert // Insufficient balance
    // smart_contracts/reti_prod/stakingPool.algo.ts:324
    // cmpStaker.balance -= amountToUnstake
    frame_dig -1
    -
    itob
    frame_dig 0
    swap
    replace2 32
    dup
    frame_bury 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:325
    // this.totalAlgoStaked.value -= amountToUnstake
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:325
    // this.totalAlgoStaked.value -= amountToUnstake
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:325
    // this.totalAlgoStaked.value -= amountToUnstake
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:327
    // let amountRewardTokenRemoved: uint64 = 0
    intc_0 // 0
    frame_bury 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:328
    // if (cmpStaker.rewardTokenBalance > 0) {
    dup
    pushint 48 // 48
    extract_uint64
    dup
    frame_bury 3
    swap
    frame_bury 1
    bz removeStake_after_if_else@16
    // smart_contracts/reti_prod/stakingPool.algo.ts:330
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:330
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz removeStake_else_body@14
    // smart_contracts/reti_prod/stakingPool.algo.ts:331-334
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:332
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:332
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:333
    // args: [this.validatorId.value],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:333
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:331-334
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/reti_prod/stakingPool.algo.ts:339-345
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker.native,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    //   })
    //   .submit()
    itxn_begin
    intc 5 // 157
    // smart_contracts/reti_prod/stakingPool.algo.ts:341
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    frame_dig 3
    itxn_field AssetAmount
    frame_dig -2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/reti_prod/stakingPool.algo.ts:339-344
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker.native,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:339-345
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker.native,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/reti_prod/stakingPool.algo.ts:347
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 0
    swap
    replace2 48
    frame_bury 0

removeStake_after_if_else@15:
    frame_dig 3
    frame_bury 2
    frame_dig 0
    frame_bury 1

removeStake_after_if_else@16:
    frame_dig 1
    dup
    frame_bury 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:359
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    pushint 32 // 32
    extract_uint64
    dup
    frame_bury 8
    bz removeStake_bool_true@18
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:88
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // smart_contracts/reti_prod/stakingPool.algo.ts:359
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 8
    <=
    bz removeStake_bool_false@19

removeStake_bool_true@18:
    intc_1 // 1

removeStake_bool_merge@20:
    // smart_contracts/reti_prod/stakingPool.algo.ts:358-361
    // assert(
    //   cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    //   'cannot reduce balance below minimum allowed stake unless all is removed',
    // )
    assert // cannot reduce balance below minimum allowed stake unless all is removed
    // smart_contracts/reti_prod/stakingPool.algo.ts:366-372
    // itxn
    //   .payment({
    //     amount: amountToUnstake,
    //     receiver: staker.native,
    //     note: 'unstaked',
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:370
    // note: 'unstaked',
    pushbytes "unstaked"
    itxn_field Note
    frame_dig -2
    itxn_field Receiver
    frame_dig -1
    itxn_field Amount
    // smart_contracts/reti_prod/stakingPool.algo.ts:366-371
    // itxn
    //   .payment({
    //     amount: amountToUnstake,
    //     receiver: staker.native,
    //     note: 'unstaked',
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:366-372
    // itxn
    //   .payment({
    //     amount: amountToUnstake,
    //     receiver: staker.native,
    //     note: 'unstaked',
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/reti_prod/stakingPool.algo.ts:373
    // let stakerRemoved = false
    intc_0 // 0
    frame_bury 7
    frame_dig 0
    frame_bury 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:374
    // if (cmpStaker.balance === 0) {
    frame_dig 8
    bnz removeStake_after_if_else@23
    // smart_contracts/reti_prod/stakingPool.algo.ts:376
    // this.numStakers.value -= 1
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:376
    // this.numStakers.value -= 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:376
    // this.numStakers.value -= 1
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:377
    // cmpStaker.account = new Address(Global.zeroAddress)
    frame_dig 0
    global ZeroAddress
    replace2 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:378
    // cmpStaker.totalRewarded = 0
    intc_0 // 0
    itob
    swap
    dig 1
    replace2 40
    // smart_contracts/reti_prod/stakingPool.algo.ts:379
    // cmpStaker.rewardTokenBalance = 0
    swap
    replace2 48
    // smart_contracts/reti_prod/stakingPool.algo.ts:380
    // stakerRemoved = true
    intc_1 // 1
    frame_bury 7
    frame_bury 1

removeStake_after_if_else@23:
    frame_dig 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:383
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 5
    uncover 2
    box_replace
    // smart_contracts/reti_prod/stakingPool.algo.ts:385
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // smart_contracts/reti_prod/stakingPool.algo.ts:385
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:385
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:386
    // const subtractAmount = BigUint(amountToUnstake * roundsLeftInBin)
    frame_dig -1
    *
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:387
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.native - subtractAmount)
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:387
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.native - subtractAmount)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    b-
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:387
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.native - subtractAmount)
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:392-401
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [
    //     { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //     staker,
    //     amountToUnstake,
    //     amountRewardTokenRemoved,
    //     stakerRemoved,
    //   ],
    // })
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:393
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:393
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:395
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:395
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:395
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationID
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:397
    // amountToUnstake,
    frame_dig -1
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:398
    // amountRewardTokenRemoved,
    frame_dig 2
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:399
    // stakerRemoved,
    pushbytes 0x00
    intc_0 // 0
    frame_dig 7
    setbit
    // smart_contracts/reti_prod/stakingPool.algo.ts:392-401
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [
    //     { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //     staker,
    //     amountToUnstake,
    //     amountRewardTokenRemoved,
    //     stakerRemoved,
    //   ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/reti_prod/stakingPool.algo.ts:402
    // return
    retsub

removeStake_bool_false@19:
    intc_0 // 0
    b removeStake_bool_merge@20

removeStake_else_body@14:
    // smart_contracts/reti_prod/stakingPool.algo.ts:353
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 0
    swap
    replace2 48
    frame_bury 0
    b removeStake_after_if_else@15

removeStake_after_if_else@25:
    // smart_contracts/reti_prod/stakingPool.algo.ts:313
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 6
    intc_1 // 1
    +
    frame_bury 6
    b removeStake_while_top@3


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.claimTokens() -> void:
claimTokens:
    // smart_contracts/reti_prod/stakingPool.algo.ts:413
    // claimTokens(): void {
    proto 0 0
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // smart_contracts/reti_prod/stakingPool.algo.ts:417
    // const staker = Txn.sender
    txn Sender
    // smart_contracts/reti_prod/stakingPool.algo.ts:419
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

claimTokens_while_top@1:
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:419
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 5
    dup
    intc 4 // 200
    <
    assert // account not found
    // smart_contracts/reti_prod/stakingPool.algo.ts:420
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/reti_prod/stakingPool.algo.ts:421
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    frame_bury 3
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:421
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:421-422
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native === staker) {
    extract 0 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:422
    // if (cmpStaker.account.native === staker) {
    frame_dig 4
    ==
    bz claimTokens_after_if_else@12
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:421
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 3
    intc_2 // 64
    box_extract
    dup
    extract 48 8
    frame_bury 0
    pushint 48 // 48
    // smart_contracts/reti_prod/stakingPool.algo.ts:423
    // if (cmpStaker.rewardTokenBalance === 0) {
    extract_uint64
    dup
    frame_bury 2
    bnz claimTokens_after_if_else@5
    // smart_contracts/reti_prod/stakingPool.algo.ts:424
    // return
    retsub

claimTokens_after_if_else@5:
    // smart_contracts/reti_prod/stakingPool.algo.ts:428
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:428
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz claimTokens_else_body@9
    // smart_contracts/reti_prod/stakingPool.algo.ts:429-432
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:430
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:430
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:431
    // args: [this.validatorId.value],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:431
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:429-432
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/reti_prod/stakingPool.algo.ts:436-442
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    //   })
    //   .submit()
    itxn_begin
    intc 5 // 157
    // smart_contracts/reti_prod/stakingPool.algo.ts:438
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    frame_dig 2
    itxn_field AssetAmount
    frame_dig 4
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/reti_prod/stakingPool.algo.ts:436-441
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:436-442
    // itxn
    //   .assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/reti_prod/stakingPool.algo.ts:444
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 1
    swap
    replace2 48
    frame_bury 1

claimTokens_after_if_else@10:
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:454
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 3
    frame_dig 1
    box_replace
    // smart_contracts/reti_prod/stakingPool.algo.ts:459-468
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [
    //     { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //     new Address(staker),
    //     0, // no algo removed
    //     amountRewardTokenRemoved,
    //     false, // staker isn't being removed.
    //   ],
    // })
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:460
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:460
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:462
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:462
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:462
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationID
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:464
    // 0, // no algo removed
    intc_0 // 0
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:459-468
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [
    //     { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //     new Address(staker),
    //     0, // no algo removed
    //     amountRewardTokenRemoved,
    //     false, // staker isn't being removed.
    //   ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    // smart_contracts/reti_prod/stakingPool.algo.ts:466
    // false, // staker isn't being removed.
    pushbytes 0x00
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/reti_prod/stakingPool.algo.ts:459-468
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [
    //     { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //     new Address(staker),
    //     0, // no algo removed
    //     amountRewardTokenRemoved,
    //     false, // staker isn't being removed.
    //   ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/reti_prod/stakingPool.algo.ts:469
    // return
    retsub

claimTokens_else_body@9:
    // smart_contracts/reti_prod/stakingPool.algo.ts:450
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 1
    swap
    replace2 48
    frame_bury 1
    b claimTokens_after_if_else@10

claimTokens_after_if_else@12:
    // smart_contracts/reti_prod/stakingPool.algo.ts:419
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 5
    intc_1 // 1
    +
    frame_bury 5
    b claimTokens_while_top@1


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.getStakerInfo(staker: bytes) -> bytes:
getStakerInfo:
    // smart_contracts/reti_prod/stakingPool.algo.ts:482-483
    // @abimethod({ readonly: true })
    // getStakerInfo(staker: Address): StakedInfo {
    proto 1 1
    pushbytes ""
    // smart_contracts/reti_prod/stakingPool.algo.ts:484
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

getStakerInfo_while_top@1:
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:484
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 1
    dup
    intc 4 // 200
    <
    assert // account not found
    // smart_contracts/reti_prod/stakingPool.algo.ts:485
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/reti_prod/stakingPool.algo.ts:486
    // if (this.stakers.value[i].account === staker) {
    intc_2 // 64
    *
    dup
    frame_bury 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:486
    // if (this.stakers.value[i].account === staker) {
    swap
    intc_2 // 64
    box_extract
    extract 0 32
    frame_dig -1
    ==
    bz getStakerInfo_after_if_else@4
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:487
    // return this.stakers.value[i]
    frame_dig 0
    intc_2 // 64
    box_extract
    frame_bury 0
    retsub

getStakerInfo_after_if_else@4:
    // smart_contracts/reti_prod/stakingPool.algo.ts:484
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b getStakerInfo_while_top@1


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.payTokenReward(staker: bytes, rewardToken: uint64, amountToSend: uint64) -> void:
payTokenReward:
    // smart_contracts/reti_prod/stakingPool.algo.ts:503
    // payTokenReward(staker: Address, rewardToken: uint64, amountToSend: uint64): void {
    proto 3 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:506
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    txn Sender
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:506
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/reti_prod/stakingPool.algo.ts:505-508
    // assert(
    //   Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    //   'this can only be called via the validator contract',
    // )
    assert // this can only be called via the validator contract
    // smart_contracts/reti_prod/stakingPool.algo.ts:509
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:509
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // must be pool 1 in order to be called to pay out token rewards
    // smart_contracts/reti_prod/stakingPool.algo.ts:510
    // assert(rewardToken !== 0, 'can only claim token rewards from validator that has them')
    frame_dig -2
    assert // can only claim token rewards from validator that has them
    // smart_contracts/reti_prod/stakingPool.algo.ts:513-519
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardToken,
    //     assetReceiver: staker.native,
    //     assetAmount: amountToSend,
    //   })
    //   .submit()
    itxn_begin
    frame_dig -1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    // smart_contracts/reti_prod/stakingPool.algo.ts:513-518
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardToken,
    //     assetReceiver: staker.native,
    //     assetAmount: amountToSend,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:513-519
    // itxn
    //   .assetTransfer({
    //     xferAsset: rewardToken,
    //     assetReceiver: staker.native,
    //     assetAmount: amountToSend,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.updateAlgodVer(algodVer: bytes) -> void:
updateAlgodVer:
    // smart_contracts/reti_prod/stakingPool.algo.ts:531
    // updateAlgodVer(algodVer: string): void {
    proto 1 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:532
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // smart_contracts/reti_prod/stakingPool.algo.ts:97
    // algodVer = GlobalState<bytes>({ key: 'algodVer' })
    pushbytes "algodVer"
    // smart_contracts/reti_prod/stakingPool.algo.ts:533
    // this.algodVer.value = Bytes(algodVer)
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.epochBalanceUpdate() -> void:
epochBalanceUpdate:
    // smart_contracts/reti_prod/stakingPool.algo.ts:544
    // epochBalanceUpdate(): void {
    proto 0 0
    intc_0 // 0
    dupn 6
    pushbytes ""
    dupn 34
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:546-549
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:547
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:547
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:548
    // args: [this.validatorId.value],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:548
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:546-549
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/reti_prod/stakingPool.algo.ts:555
    // const epochRoundLength = validatorConfig.epochRoundLength.native
    dup
    pushint 173 // 173
    extract_uint32
    dup
    cover 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:556
    // const curRound = Global.round
    global Round
    // smart_contracts/reti_prod/stakingPool.algo.ts:557
    // const thisEpochBegin: uint64 = curRound - (curRound % epochRoundLength)
    dup
    dig 2
    %
    dig 1
    swap
    -
    dup
    cover 2
    cover 4
    // smart_contracts/reti_prod/stakingPool.algo.ts:560
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:91
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // smart_contracts/reti_prod/stakingPool.algo.ts:560
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    app_global_get_ex
    assert // check GlobalState exists
    dup
    uncover 4
    %
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:562
    // assert(lastPayoutEpoch !== thisEpochBegin, "can't call epochBalanceUpdate in same epoch as prior call")
    uncover 2
    !=
    assert // can't call epochBalanceUpdate in same epoch as prior call
    // smart_contracts/reti_prod/stakingPool.algo.ts:564
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // smart_contracts/reti_prod/stakingPool.algo.ts:91
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // smart_contracts/reti_prod/stakingPool.algo.ts:567
    // this.lastPayout.value = curRound
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:568
    // this.epochNumber.value += 1
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:94
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // smart_contracts/reti_prod/stakingPool.algo.ts:568
    // this.epochNumber.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/reti_prod/stakingPool.algo.ts:94
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // smart_contracts/reti_prod/stakingPool.algo.ts:568
    // this.epochNumber.value += 1
    swap
    app_global_put
    intc 5 // 157
    // smart_contracts/reti_prod/stakingPool.algo.ts:573
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // smart_contracts/reti_prod/stakingPool.algo.ts:574
    // let poolOneAppID = Global.currentApplicationId.id
    global CurrentApplicationID
    swap
    // smart_contracts/reti_prod/stakingPool.algo.ts:575
    // let poolOneAddress = Global.currentApplicationAddress
    global CurrentApplicationAddress
    dup
    cover 2
    swap
    // smart_contracts/reti_prod/stakingPool.algo.ts:580
    // if (isTokenEligible) {
    bz epochBalanceUpdate_after_if_else@11
    // smart_contracts/reti_prod/stakingPool.algo.ts:581
    // if (this.poolId.value !== 1) {
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:581
    // if (this.poolId.value !== 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    !=
    bz epochBalanceUpdate_after_if_else@5
    // smart_contracts/reti_prod/stakingPool.algo.ts:583-586
    // poolOneAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value, 1],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:584
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:584
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:585
    // args: [this.validatorId.value, 1],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:585
    // args: [this.validatorId.value, 1],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_1 // 1
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:583-586
    // poolOneAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value, 1],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    dup
    frame_bury 47
    // smart_contracts/reti_prod/stakingPool.algo.ts:588
    // poolOneAddress = Application(poolOneAppID).address
    app_params_get AppAddress
    swap
    frame_bury 48
    assert // application exists

epochBalanceUpdate_after_if_else@5:
    // smart_contracts/reti_prod/stakingPool.algo.ts:593
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:593
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz epochBalanceUpdate_else_body@8
    // smart_contracts/reti_prod/stakingPool.algo.ts:594-597
    // tokenPayoutRatio = abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:595
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:595
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:596
    // args: [this.validatorId.value],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:596
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:594-597
    // tokenPayoutRatio = abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    frame_bury 42
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix

epochBalanceUpdate_after_if_else@10:
    frame_dig 48
    frame_bury 49

epochBalanceUpdate_after_if_else@11:
    frame_dig 49
    frame_bury 48
    // smart_contracts/reti_prod/stakingPool.algo.ts:609-612
    // const validatorState = abiCall(ValidatorRegistryInterface.prototype.getValidatorState, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:610
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:610
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:611
    // args: [this.validatorId.value],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:611
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:609-612
    // const validatorState = abiCall(ValidatorRegistryInterface.prototype.getValidatorState, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/reti_prod/stakingPool.algo.ts:613
    // const rewardTokenHeldBack = validatorState.rewardTokenHeldBack
    dup
    pushint 22 // 22
    extract_uint64
    frame_bury 26
    // smart_contracts/reti_prod/stakingPool.algo.ts:620
    // Global.currentApplicationAddress.balance -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/reti_prod/stakingPool.algo.ts:621
    // this.totalAlgoStaked.value -
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:621
    // this.totalAlgoStaked.value -
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:620-621
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:622
    // Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/reti_prod/stakingPool.algo.ts:620-622
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    // Global.currentApplicationAddress.minBalance
    -
    frame_bury 7
    // smart_contracts/reti_prod/stakingPool.algo.ts:623
    // let isPoolSaturated = false
    intc_0 // 0
    frame_bury 19
    // smart_contracts/reti_prod/stakingPool.algo.ts:1025
    // return op.onlineStake()
    online_stake
    // smart_contracts/reti_prod/stakingPool.algo.ts:1012
    // return wideRatio([online, MAX_VALIDATOR_SOFT_PCT_OF_ONLINE_1DECIMAL], [1000])
    itob
    bytec 8 // 0x0002
    swap
    concat
    pushint 100 // 100
    itob
    concat
    pushint 1000 // 1000
    itob
    frame_bury 2
    pushbytes 0x000100000000000003e8
    callsub wideRatio
    popn 2
    dup
    frame_bury 10
    // smart_contracts/reti_prod/stakingPool.algo.ts:632
    // if (validatorState.totalAlgoStaked > algoSaturationAmt) {
    swap
    pushint 14 // 14
    extract_uint64
    dup
    frame_bury 39
    <
    bz epochBalanceUpdate_after_if_else@14
    // smart_contracts/reti_prod/stakingPool.algo.ts:633
    // isPoolSaturated = true
    intc_1 // 1
    frame_bury 19

epochBalanceUpdate_after_if_else@14:
    // smart_contracts/reti_prod/stakingPool.algo.ts:639
    // let tokenRewardAvail: uint64 = 0
    intc_0 // 0
    dup
    frame_bury 31
    // smart_contracts/reti_prod/stakingPool.algo.ts:640
    // let tokenRewardPaidOut: uint64 = 0
    intc_0 // 0
    frame_bury 34
    // smart_contracts/reti_prod/stakingPool.algo.ts:641
    // let validatorCommissionPaidOut: uint64 = 0
    intc_0 // 0
    frame_bury 36
    // smart_contracts/reti_prod/stakingPool.algo.ts:642
    // let excessToFeeSink: uint64 = 0
    intc_0 // 0
    frame_bury 15
    frame_bury 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:643
    // if (isTokenEligible) {
    frame_dig 46
    bz epochBalanceUpdate_after_if_else@18
    // smart_contracts/reti_prod/stakingPool.algo.ts:645
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    frame_dig 48
    frame_dig 46
    asset_holding_get AssetBalance
    pop
    // smart_contracts/reti_prod/stakingPool.algo.ts:646
    // op.btoi(Bytes(rewardTokenHeldBack))
    frame_dig 26
    itob
    btoi
    // smart_contracts/reti_prod/stakingPool.algo.ts:645-646
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    // op.btoi(Bytes(rewardTokenHeldBack))
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:650
    // if (tokenRewardBal >= validatorConfig.rewardPerPayout) {
    frame_dig 43
    pushint 165 // 165
    extract_uint64
    dup
    frame_bury 40
    >=
    bz epochBalanceUpdate_after_if_else@17
    // smart_contracts/reti_prod/stakingPool.algo.ts:656
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:656
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    frame_dig 42
    extract 0 192
    swap
    pushint 8 // 8
    *
    extract_uint64
    // smart_contracts/reti_prod/stakingPool.algo.ts:659
    // tokenRewardAvail = wideRatio([validatorConfig.rewardPerPayout, ourPoolPctOfWhole], [1_000_000])
    frame_dig 40
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    itob
    concat
    bytec 18 // 0x000100000000000f4240
    callsub wideRatio
    popn 2
    frame_bury 31

epochBalanceUpdate_after_if_else@17:
    frame_dig 31
    frame_bury 32

epochBalanceUpdate_after_if_else@18:
    frame_dig 32
    dup
    frame_bury 31
    // smart_contracts/reti_prod/stakingPool.algo.ts:662
    // if (tokenRewardAvail === 0) {
    bnz epochBalanceUpdate_after_if_else@22
    // smart_contracts/reti_prod/stakingPool.algo.ts:667
    // if (algoRewardAvail < 1_000_000) {
    frame_dig 7
    intc 8 // 1000000
    <
    bz epochBalanceUpdate_after_if_else@22
    // smart_contracts/reti_prod/stakingPool.algo.ts:668
    // log('!token&&!noalgo to pay')
    pushbytes "!token&&!noalgo to pay"
    log
    // smart_contracts/reti_prod/stakingPool.algo.ts:669
    // return
    retsub

epochBalanceUpdate_after_if_else@22:
    // smart_contracts/reti_prod/stakingPool.algo.ts:673
    // if (isPoolSaturated) {
    frame_dig 19
    bz epochBalanceUpdate_else_body@27
    // smart_contracts/reti_prod/stakingPool.algo.ts:680
    // [algoRewardAvail, validatorConfig.percentToValidator.native],
    frame_dig 43
    pushint 177 // 177
    extract_uint32
    frame_dig 7
    dup
    cover 2
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    itob
    dig 1
    swap
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:681
    // [1_000_000],
    bytec 18 // 0x000100000000000f4240
    // smart_contracts/reti_prod/stakingPool.algo.ts:679-682
    // const normalValidatorCommission = wideRatio(
    //   [algoRewardAvail, validatorConfig.percentToValidator.native],
    //   [1_000_000],
    // )
    callsub wideRatio
    popn 2
    swap
    // smart_contracts/reti_prod/stakingPool.algo.ts:685
    // [algoRewardAvail, algoSaturationAmt],
    frame_dig 10
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:686
    // [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    frame_dig 39
    itob
    btoi
    itob
    bytec 19 // 0x0001
    swap
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:684-687
    // let diminishedReward = wideRatio(
    //   [algoRewardAvail, algoSaturationAmt],
    //   [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    // )
    callsub wideRatio
    popn 2
    dup
    frame_bury 13
    // smart_contracts/reti_prod/stakingPool.algo.ts:689
    // if (diminishedReward > algoRewardAvail - normalValidatorCommission) {
    cover 2
    -
    dup
    frame_bury 14
    >
    bz epochBalanceUpdate_after_if_else@25
    frame_dig 14
    frame_bury 13

epochBalanceUpdate_after_if_else@25:
    // smart_contracts/reti_prod/stakingPool.algo.ts:693
    // excessToFeeSink = algoRewardAvail - diminishedReward
    frame_dig 7
    frame_dig 13
    dup
    cover 2
    -
    dup
    frame_bury 15
    // smart_contracts/reti_prod/stakingPool.algo.ts:694-700
    // itxn
    //   .payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:697
    // receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    txn FirstValid
    intc_1 // 1
    -
    block BlkFeeSink
    // smart_contracts/reti_prod/stakingPool.algo.ts:698
    // note: 'pool saturated, excess to fee sink',
    pushbytes "pool saturated, excess to fee sink"
    itxn_field Note
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/reti_prod/stakingPool.algo.ts:694-699
    // itxn
    //   .payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:694-700
    // itxn
    //   .payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    //   })
    //   .submit()
    itxn_submit
    frame_bury 7

epochBalanceUpdate_after_if_else@39:
    // smart_contracts/reti_prod/stakingPool.algo.ts:751
    // let increasedStake: uint64 = 0
    intc_0 // 0
    frame_bury 17
    // smart_contracts/reti_prod/stakingPool.algo.ts:775
    // if (algoRewardAvail !== 0 || tokenRewardAvail !== 0) {
    frame_dig 7
    bnz epochBalanceUpdate_if_body@41
    frame_dig 34
    frame_bury 35
    frame_dig 17
    frame_bury 18
    frame_dig 31
    bz epochBalanceUpdate_after_if_else@68

epochBalanceUpdate_if_body@41:
    // smart_contracts/reti_prod/stakingPool.algo.ts:776
    // let partialStakersTotalStake: uint64 = 0
    intc_0 // 0
    frame_bury 24
    // smart_contracts/reti_prod/stakingPool.algo.ts:780
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    frame_bury 16
    frame_dig 7
    frame_bury 8
    frame_dig 31
    frame_bury 32

epochBalanceUpdate_while_top@42:
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:780
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 16
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_while@53
    // smart_contracts/reti_prod/stakingPool.algo.ts:781
    // ensureBudget(400)
    pushint 400 // 400
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/reti_prod/stakingPool.algo.ts:782
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 16
    intc_2 // 64
    *
    dup
    frame_bury 11
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:782
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 3
    // smart_contracts/reti_prod/stakingPool.algo.ts:782-783
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native !== Global.zeroAddress) {
    extract 0 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:783
    // if (cmpStaker.account.native !== Global.zeroAddress) {
    global ZeroAddress
    !=
    frame_dig 17
    frame_bury 18
    frame_dig 8
    frame_bury 9
    frame_dig 34
    frame_bury 35
    frame_dig 32
    frame_bury 33
    frame_dig 24
    frame_bury 25
    bz epochBalanceUpdate_after_if_else@52
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:782
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 56 // 56
    // smart_contracts/reti_prod/stakingPool.algo.ts:784
    // if (cmpStaker.entryRound >= thisEpochBegin) {
    extract_uint64
    dup
    frame_bury 41
    frame_dig 45
    >=
    bz epochBalanceUpdate_else_body@46
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:782
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:787
    // partialStakersTotalStake += cmpStaker.balance
    extract_uint64
    frame_dig 24
    +
    frame_bury 24

epochBalanceUpdate_after_if_else@51:
    frame_dig 17
    frame_bury 18
    frame_dig 8
    frame_bury 9
    frame_dig 34
    frame_bury 35
    frame_dig 32
    frame_bury 33
    frame_dig 24
    frame_bury 25

epochBalanceUpdate_after_if_else@52:
    frame_dig 18
    frame_bury 17
    frame_dig 9
    frame_bury 8
    frame_dig 35
    frame_bury 34
    frame_dig 33
    frame_bury 32
    frame_dig 25
    frame_bury 24
    // smart_contracts/reti_prod/stakingPool.algo.ts:780
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 16
    intc_1 // 1
    +
    frame_bury 16
    b epochBalanceUpdate_while_top@42

epochBalanceUpdate_else_body@46:
    // smart_contracts/reti_prod/stakingPool.algo.ts:791
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    frame_dig 45
    frame_dig 41
    -
    dup
    frame_bury 27
    // smart_contracts/reti_prod/stakingPool.algo.ts:795
    // if (timeInPool < epochRoundLength) {
    frame_dig 44
    <
    frame_dig 17
    frame_bury 18
    frame_dig 8
    frame_bury 9
    frame_dig 34
    frame_bury 35
    frame_dig 32
    frame_bury 33
    frame_dig 24
    frame_bury 25
    bz epochBalanceUpdate_after_if_else@50
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:782
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:796
    // partialStakersTotalStake += cmpStaker.balance
    extract_uint64
    dup
    frame_bury 37
    frame_dig 24
    +
    frame_bury 24
    // smart_contracts/reti_prod/stakingPool.algo.ts:797
    // timePercentage = (timeInPool * 1000) / epochRoundLength
    frame_dig 27
    pushint 1000 // 1000
    *
    frame_dig 44
    /
    frame_bury 28
    frame_dig 34
    frame_bury 35
    frame_dig 32
    dup
    frame_bury 33
    frame_dig 3
    frame_bury 4
    // smart_contracts/reti_prod/stakingPool.algo.ts:799
    // if (tokenRewardAvail > 0) {
    bz epochBalanceUpdate_after_if_else@49
    // smart_contracts/reti_prod/stakingPool.algo.ts:802
    // [cmpStaker.balance, origTokenReward, timePercentage],
    frame_dig 37
    itob
    bytec 27 // 0x0003
    swap
    concat
    frame_dig 31
    itob
    concat
    frame_dig 28
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:803
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:803
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 2
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:801-804
    // const stakerTokenReward = wideRatio(
    //   [cmpStaker.balance, origTokenReward, timePercentage],
    //   [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:808
    // tokenRewardAvail -= stakerTokenReward
    frame_dig 32
    dig 1
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:782
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 48 // 48
    // smart_contracts/reti_prod/stakingPool.algo.ts:809
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    extract_uint64
    dig 2
    +
    itob
    frame_dig 3
    swap
    replace2 48
    // smart_contracts/reti_prod/stakingPool.algo.ts:810
    // tokenRewardPaidOut += stakerTokenReward
    frame_dig 34
    uncover 3
    +
    frame_bury 35
    frame_bury 4
    frame_bury 33

epochBalanceUpdate_after_if_else@49:
    frame_dig 33
    frame_dig 35
    frame_dig 4
    // smart_contracts/reti_prod/stakingPool.algo.ts:814
    // [cmpStaker.balance, origAlgoReward, timePercentage],
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 27 // 0x0003
    swap
    concat
    frame_dig 7
    itob
    concat
    frame_dig 28
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:815
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:815
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 2
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:813-816
    // const stakerReward = wideRatio(
    //   [cmpStaker.balance, origAlgoReward, timePercentage],
    //   [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:819
    // algoRewardAvail -= stakerReward
    frame_dig 8
    dig 1
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:822
    // cmpStaker.balance += stakerReward
    uncover 2
    dig 2
    +
    itob
    uncover 3
    swap
    replace2 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:823
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 3
    +
    itob
    replace2 40
    // smart_contracts/reti_prod/stakingPool.algo.ts:824
    // increasedStake += stakerReward
    frame_dig 17
    uncover 3
    +
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:826
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 11
    uncover 3
    box_replace
    frame_bury 18
    frame_bury 9
    frame_bury 35
    frame_bury 33
    frame_dig 24
    frame_bury 25

epochBalanceUpdate_after_if_else@50:
    frame_dig 18
    frame_bury 17
    frame_dig 9
    frame_bury 8
    frame_dig 35
    frame_bury 34
    frame_dig 33
    frame_bury 32
    frame_dig 25
    frame_bury 24
    b epochBalanceUpdate_after_if_else@51

epochBalanceUpdate_after_while@53:
    // smart_contracts/reti_prod/stakingPool.algo.ts:834
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:834
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 24
    -
    dup
    frame_bury 23
    frame_dig 34
    frame_bury 35
    frame_dig 17
    frame_bury 18
    // smart_contracts/reti_prod/stakingPool.algo.ts:838
    // if (newPoolTotalStake > 0) {
    bz epochBalanceUpdate_after_if_else@67
    // smart_contracts/reti_prod/stakingPool.algo.ts:840
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    frame_bury 20

epochBalanceUpdate_while_top@55:
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:840
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 20
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_while@66
    // smart_contracts/reti_prod/stakingPool.algo.ts:841
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/reti_prod/stakingPool.algo.ts:842
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 20
    intc_2 // 64
    *
    dup
    frame_bury 12
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:842
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 5
    // smart_contracts/reti_prod/stakingPool.algo.ts:842-843
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract 0 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:843
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    global ZeroAddress
    !=
    frame_dig 17
    frame_bury 18
    frame_dig 34
    frame_bury 35
    bz epochBalanceUpdate_after_if_else@65
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:842-843
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    frame_dig 12
    intc_2 // 64
    box_extract
    pushint 56 // 56
    // smart_contracts/reti_prod/stakingPool.algo.ts:843
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract_uint64
    dup
    frame_bury 38
    frame_dig 45
    <
    frame_dig 17
    frame_bury 18
    frame_dig 34
    frame_bury 35
    bz epochBalanceUpdate_after_if_else@65
    // smart_contracts/reti_prod/stakingPool.algo.ts:844
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    frame_dig 45
    frame_dig 38
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:846
    // if (timeInPool >= epochRoundLength) {
    frame_dig 44
    >=
    frame_dig 17
    frame_bury 18
    frame_dig 34
    frame_bury 35
    bz epochBalanceUpdate_after_if_else@64
    frame_dig 34
    frame_bury 35
    frame_dig 5
    frame_bury 6
    // smart_contracts/reti_prod/stakingPool.algo.ts:851
    // if (tokenRewardAvail > 0) {
    frame_dig 32
    bz epochBalanceUpdate_after_if_else@61
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:842
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 12
    dup
    cover 2
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:852
    // const stakerTokenReward = wideRatio([cmpStaker.balance, tokenRewardAvail], [newPoolTotalStake])
    extract_uint64
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 32
    itob
    concat
    frame_dig 23
    itob
    bytec 19 // 0x0001
    swap
    concat
    callsub wideRatio
    popn 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:842
    // const cmpStaker = clone(this.stakers.value[i])
    uncover 2
    intc_2 // 64
    box_extract
    pushint 48 // 48
    // smart_contracts/reti_prod/stakingPool.algo.ts:854
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    extract_uint64
    dig 1
    +
    itob
    frame_dig 5
    swap
    replace2 48
    // smart_contracts/reti_prod/stakingPool.algo.ts:855
    // tokenRewardPaidOut += stakerTokenReward
    frame_dig 34
    uncover 2
    +
    frame_bury 35
    frame_bury 6

epochBalanceUpdate_after_if_else@61:
    frame_dig 35
    frame_bury 34
    frame_dig 6
    dup
    frame_bury 5
    frame_dig 17
    frame_bury 18
    frame_bury 6
    // smart_contracts/reti_prod/stakingPool.algo.ts:857
    // if (algoRewardAvail > 0) {
    frame_dig 8
    bz epochBalanceUpdate_after_if_else@63
    // smart_contracts/reti_prod/stakingPool.algo.ts:858
    // const stakerReward = wideRatio([cmpStaker.balance, algoRewardAvail], [newPoolTotalStake])
    frame_dig 5
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 8
    itob
    concat
    frame_dig 23
    itob
    bytec 19 // 0x0001
    swap
    concat
    callsub wideRatio
    popn 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:861
    // cmpStaker.balance += stakerReward
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 32
    // smart_contracts/reti_prod/stakingPool.algo.ts:862
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 2
    +
    itob
    replace2 40
    // smart_contracts/reti_prod/stakingPool.algo.ts:863
    // increasedStake += stakerReward
    frame_dig 17
    uncover 2
    +
    frame_bury 18
    frame_bury 6

epochBalanceUpdate_after_if_else@63:
    frame_dig 18
    frame_dig 6
    // smart_contracts/reti_prod/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // smart_contracts/reti_prod/stakingPool.algo.ts:867
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 12
    uncover 2
    box_replace
    frame_bury 18
    frame_dig 34
    frame_bury 35

epochBalanceUpdate_after_if_else@64:
    b epochBalanceUpdate_after_if_else@65

epochBalanceUpdate_after_if_else@65:
    frame_dig 18
    frame_bury 17
    frame_dig 35
    frame_bury 34
    // smart_contracts/reti_prod/stakingPool.algo.ts:840
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 20
    intc_1 // 1
    +
    frame_bury 20
    b epochBalanceUpdate_while_top@55

epochBalanceUpdate_after_while@66:
    frame_dig 34
    frame_bury 35
    frame_dig 17
    frame_bury 18

epochBalanceUpdate_after_if_else@67:
    b epochBalanceUpdate_after_if_else@68

epochBalanceUpdate_after_if_else@68:
    frame_dig 35
    frame_dig 18
    // smart_contracts/reti_prod/stakingPool.algo.ts:877
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // smart_contracts/reti_prod/stakingPool.algo.ts:877
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:877
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:878
    // this.totalAlgoStaked.value += increasedStake
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:878
    // this.totalAlgoStaked.value += increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    +
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:878
    // this.totalAlgoStaked.value += increasedStake
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:880
    // this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:880
    // this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    itob
    uncover 2
    itob
    dig 1
    b*
    uncover 2
    b+
    // smart_contracts/reti_prod/stakingPool.algo.ts:879-881
    // this.stakeAccumulator.value = new Uint128(
    //   this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:879-881
    // this.stakeAccumulator.value = new Uint128(
    //   this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:882
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:882
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    // smart_contracts/reti_prod/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:882
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:888-897
    // abiCall(ValidatorRegistryInterface.prototype.stakeUpdatedViaRewards, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [
    //     { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //     increasedStake,
    //     tokenRewardPaidOut,
    //     validatorCommissionPaidOut,
    //     excessToFeeSink,
    //   ],
    // })
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:889
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:889
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:891
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:891
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:891
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationID
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:893
    // tokenRewardPaidOut,
    uncover 3
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:894
    // validatorCommissionPaidOut,
    frame_dig 36
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:895
    // excessToFeeSink,
    frame_dig 15
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:888-897
    // abiCall(ValidatorRegistryInterface.prototype.stakeUpdatedViaRewards, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [
    //     { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //     increasedStake,
    //     tokenRewardPaidOut,
    //     validatorCommissionPaidOut,
    //     excessToFeeSink,
    //   ],
    // })
    pushbytes 0x418fcefc // method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub

epochBalanceUpdate_else_body@27:
    // smart_contracts/reti_prod/stakingPool.algo.ts:703
    // } else if (validatorConfig.percentToValidator.native !== 0) {
    frame_dig 43
    pushint 177 // 177
    extract_uint32
    dup
    frame_bury 29
    frame_dig 7
    frame_bury 8
    bz epochBalanceUpdate_after_if_else@38
    // smart_contracts/reti_prod/stakingPool.algo.ts:706
    // validatorCommissionPaidOut = wideRatio([algoRewardAvail, validatorConfig.percentToValidator.native], [1_000_000])
    frame_dig 7
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 29
    itob
    concat
    bytec 18 // 0x000100000000000f4240
    callsub wideRatio
    popn 2
    dup
    frame_bury 36
    // smart_contracts/reti_prod/stakingPool.algo.ts:709
    // algoRewardAvail -= validatorCommissionPaidOut
    swap
    dig 1
    -
    frame_bury 7
    // smart_contracts/reti_prod/stakingPool.algo.ts:716
    // if (validatorCommissionPaidOut > 0) {
    bz epochBalanceUpdate_after_if_else@37
    // smart_contracts/reti_prod/stakingPool.algo.ts:719
    // let managerTopOff: uint64 = 0
    intc_0 // 0
    dup
    frame_bury 21
    // smart_contracts/reti_prod/stakingPool.algo.ts:721
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    frame_dig 43
    dup
    extract 44 32
    dup
    cover 2
    frame_bury 0
    extract 181 32
    dup
    frame_bury 1
    !=
    swap
    frame_bury 22
    // smart_contracts/reti_prod/stakingPool.algo.ts:721-722
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.native.balance - validatorConfig.manager.native.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@33
    // smart_contracts/reti_prod/stakingPool.algo.ts:722
    // validatorConfig.manager.native.balance - validatorConfig.manager.native.minBalance < 2_100_000
    frame_dig 0
    dup
    acct_params_get AcctBalance
    assert // account funded
    swap
    acct_params_get AcctMinBalance
    assert // account funded
    -
    intc 7 // 2100000
    <
    frame_dig 21
    frame_bury 22
    // smart_contracts/reti_prod/stakingPool.algo.ts:721-722
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.native.balance - validatorConfig.manager.native.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@33
    // smart_contracts/reti_prod/stakingPool.algo.ts:724
    // managerTopOff = validatorCommissionPaidOut < 2_100_000 ? validatorCommissionPaidOut : 2_100_000
    frame_dig 36
    dup
    intc 7 // 2100000
    <
    intc 7 // 2100000
    cover 2
    select
    // smart_contracts/reti_prod/stakingPool.algo.ts:725-731
    // itxn
    //   .payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager.native,
    //     note: 'validator reward to manager for funding epoch updates',
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:729
    // note: 'validator reward to manager for funding epoch updates',
    pushbytes "validator reward to manager for funding epoch updates"
    itxn_field Note
    frame_dig 0
    itxn_field Receiver
    dup
    itxn_field Amount
    // smart_contracts/reti_prod/stakingPool.algo.ts:725-730
    // itxn
    //   .payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager.native,
    //     note: 'validator reward to manager for funding epoch updates',
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:725-731
    // itxn
    //   .payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager.native,
    //     note: 'validator reward to manager for funding epoch updates',
    //   })
    //   .submit()
    itxn_submit
    frame_bury 22

epochBalanceUpdate_after_if_else@33:
    // smart_contracts/reti_prod/stakingPool.algo.ts:733
    // if (validatorCommissionPaidOut - managerTopOff > 0) {
    frame_dig 36
    frame_dig 22
    -
    dup
    frame_bury 30
    bz epochBalanceUpdate_after_if_else@37
    // smart_contracts/reti_prod/stakingPool.algo.ts:734-740
    // itxn
    //   .payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress.native,
    //     note: 'validator reward',
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:738
    // note: 'validator reward',
    pushbytes "validator reward"
    itxn_field Note
    frame_dig 1
    itxn_field Receiver
    frame_dig 30
    itxn_field Amount
    // smart_contracts/reti_prod/stakingPool.algo.ts:734-739
    // itxn
    //   .payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress.native,
    //     note: 'validator reward',
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:734-740
    // itxn
    //   .payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress.native,
    //     note: 'validator reward',
    //   })
    //   .submit()
    itxn_submit

epochBalanceUpdate_after_if_else@37:
    frame_dig 7
    frame_bury 8

epochBalanceUpdate_after_if_else@38:
    frame_dig 8
    frame_bury 7
    b epochBalanceUpdate_after_if_else@39

epochBalanceUpdate_else_body@8:
    // smart_contracts/reti_prod/stakingPool.algo.ts:600-603
    // tokenPayoutRatio = abiCall(StakingPool.prototype.proxiedSetTokenPayoutRatio, {
    //   appId: Application(poolOneAppID),
    //   args: [{ id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id }],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:602
    // args: [{ id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id }],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:602
    // args: [{ id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id }],
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:602
    // args: [{ id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id }],
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationID
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/reti_prod/stakingPool.algo.ts:600-603
    // tokenPayoutRatio = abiCall(StakingPool.prototype.proxiedSetTokenPayoutRatio, {
    //   appId: Application(poolOneAppID),
    //   args: [{ id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id }],
    // }).returnValue
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 47
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    frame_bury 42
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    b epochBalanceUpdate_after_if_else@10


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.goOnline(feePayment: uint64, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64) -> void:
goOnline:
    // smart_contracts/reti_prod/stakingPool.algo.ts:913-921
    // goOnline(
    //   feePayment: gtxn.PaymentTxn,
    //   votePK: bytes<32>,
    //   selectionPK: bytes<32>,
    //   stateProofPK: bytes<64>,
    //   voteFirst: uint64,
    //   voteLast: uint64,
    //   voteKeyDilution: uint64,
    // ): void {
    proto 7 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:922
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // smart_contracts/reti_prod/stakingPool.algo.ts:1018
    // if (!op.AcctParams.acctIncentiveEligible(Global.currentApplicationAddress)[0]) {
    global CurrentApplicationAddress
    acct_params_get AcctIncentiveEligible
    pop
    bnz goOnline_after_if_else@4
    // smart_contracts/reti_prod/stakingPool.algo.ts:1019
    // return Global.payoutsGoOnlineFee
    global PayoutsGoOnlineFee

goOnline_after_inlined_smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.getGoOnlineFee@5:
    // smart_contracts/reti_prod/stakingPool.algo.ts:924
    // assertMatch(feePayment, { receiver: Global.currentApplicationAddress, amount: extraFee })
    frame_dig -7
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    frame_dig -7
    gtxns Amount
    dig 2
    ==
    &&
    assert // assert target is match for conditions
    // smart_contracts/reti_prod/stakingPool.algo.ts:925-935
    // itxn
    //   .keyRegistration({
    //     voteKey: votePK,
    //     selectionKey: selectionPK,
    //     stateProofKey: stateProofPK,
    //     voteFirst: voteFirst,
    //     voteLast: voteLast,
    //     voteKeyDilution: voteKeyDilution,
    //     fee: extraFee,
    //   })
    //   .submit()
    itxn_begin
    frame_dig -1
    itxn_field VoteKeyDilution
    frame_dig -2
    itxn_field VoteLast
    frame_dig -3
    itxn_field VoteFirst
    frame_dig -4
    itxn_field StateProofPK
    frame_dig -5
    itxn_field SelectionPK
    frame_dig -6
    itxn_field VotePK
    // smart_contracts/reti_prod/stakingPool.algo.ts:925-934
    // itxn
    //   .keyRegistration({
    //     voteKey: votePK,
    //     selectionKey: selectionPK,
    //     stateProofKey: stateProofPK,
    //     voteFirst: voteFirst,
    //     voteLast: voteLast,
    //     voteKeyDilution: voteKeyDilution,
    //     fee: extraFee,
    //   })
    pushint 2 // 2
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:925-935
    // itxn
    //   .keyRegistration({
    //     voteKey: votePK,
    //     selectionKey: selectionPK,
    //     stateProofKey: stateProofPK,
    //     voteFirst: voteFirst,
    //     voteLast: voteLast,
    //     voteKeyDilution: voteKeyDilution,
    //     fee: extraFee,
    //   })
    //   .submit()
    itxn_submit
    retsub

goOnline_after_if_else@4:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1021
    // return 0
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:923
    // const extraFee = this.getGoOnlineFee()
    b goOnline_after_inlined_smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.getGoOnlineFee@5


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.goOffline() -> void:
goOffline:
    // smart_contracts/reti_prod/stakingPool.algo.ts:946
    // if (Txn.sender !== Application(this.creatingValidatorContractAppId.value).address) {
    txn Sender
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:946
    // if (Txn.sender !== Application(this.creatingValidatorContractAppId.value).address) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    !=
    bz goOffline_after_if_else@2
    // smart_contracts/reti_prod/stakingPool.algo.ts:947
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator

goOffline_after_if_else@2:
    // smart_contracts/reti_prod/stakingPool.algo.ts:950
    // itxn.keyRegistration({}).submit()
    itxn_begin
    pushint 2 // 2
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.linkToNFD(nfdAppId: uint64, nfdName: bytes) -> void:
linkToNFD:
    // smart_contracts/reti_prod/stakingPool.algo.ts:956
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    proto 2 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:957
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // smart_contracts/reti_prod/stakingPool.algo.ts:959-970
    // itxn
    //   .applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //       Bytes('verify_nfd_addr'),
    //       Bytes(nfdName),
    //       op.itob(nfdAppId),
    //       encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:961
    // appId: Application(nfdRegistryAppId),
    intc 10 // TMPL_NFD_REGISTRY_APP_ID
    // smart_contracts/reti_prod/stakingPool.algo.ts:965
    // op.itob(nfdAppId),
    frame_dig -2
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:966
    // encodeArc4(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    frame_dig -2
    itxn_field Applications
    // smart_contracts/reti_prod/stakingPool.algo.ts:963
    // Bytes('verify_nfd_addr'),
    pushbytes "verify_nfd_addr"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/reti_prod/stakingPool.algo.ts:959-969
    // itxn
    //   .applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //       Bytes('verify_nfd_addr'),
    //       Bytes(nfdName),
    //       op.itob(nfdAppId),
    //       encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/reti_prod/stakingPool.algo.ts:959-970
    // itxn
    //   .applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //       Bytes('verify_nfd_addr'),
    //       Bytes(nfdName),
    //       op.itob(nfdAppId),
    //       encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.proxiedSetTokenPayoutRatio(poolKey: bytes) -> bytes:
proxiedSetTokenPayoutRatio:
    // smart_contracts/reti_prod/stakingPool.algo.ts:979
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    proto 1 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:980
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:980
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    extract 0 8
    frame_dig -1
    intc_0 // 0
    extract_uint64
    dig 2
    ==
    assert // caller must be part of same validator set!
    // smart_contracts/reti_prod/stakingPool.algo.ts:981
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:981
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // callee must be pool 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:982
    // assert(poolKey.poolId !== 1, 'caller must NOT be pool 1')
    frame_dig -1
    extract 8 8
    frame_dig -1
    pushint 8 // 8
    extract_uint64
    intc_1 // 1
    !=
    assert // caller must NOT be pool 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:984-987
    // const callerPoolAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:985
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:985
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:984-987
    // const callerPoolAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // smart_contracts/reti_prod/stakingPool.algo.ts:988
    // assert(callerPoolAppID === poolKey.poolAppId)
    frame_dig -1
    intc_3 // 16
    extract_uint64
    swap
    dig 1
    ==
    assert
    // smart_contracts/reti_prod/stakingPool.algo.ts:989
    // assert(Txn.sender === Application(poolKey.poolAppId).address)
    txn Sender
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    assert
    // smart_contracts/reti_prod/stakingPool.algo.ts:991-994
    // return abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:993
    // args: [this.validatorId.value],
    swap
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:991-994
    // return abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    retsub


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.isOwnerOrManagerCaller() -> uint64:
isOwnerOrManagerCaller:
    // smart_contracts/reti_prod/stakingPool.algo.ts:997
    // private isOwnerOrManagerCaller(): boolean {
    proto 0 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:998-1001
    // const OwnerAndManager = abiCall(ValidatorRegistryInterface.prototype.getValidatorOwnerAndManager, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // smart_contracts/reti_prod/stakingPool.algo.ts:999
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // smart_contracts/reti_prod/stakingPool.algo.ts:999
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:1000
    // args: [this.validatorId.value],
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1000
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // smart_contracts/reti_prod/stakingPool.algo.ts:998-1001
    // const OwnerAndManager = abiCall(ValidatorRegistryInterface.prototype.getValidatorOwnerAndManager, {
    //   appId: this.creatingValidatorContractAppId.value,
    //   args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x2fa22c4b // method "getValidatorOwnerAndManager(uint64)(address,address)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // smart_contracts/reti_prod/stakingPool.algo.ts:1002
    // return Txn.sender === OwnerAndManager[0].native || Txn.sender === OwnerAndManager[1].native
    txn Sender
    swap
    extract 4 32
    ==
    bnz isOwnerOrManagerCaller_bool_true@3
    txn Sender
    frame_dig 0
    extract 36 32
    ==
    bz isOwnerOrManagerCaller_bool_false@4

isOwnerOrManagerCaller_bool_true@3:
    intc_1 // 1

isOwnerOrManagerCaller_bool_merge@5:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1002
    // return Txn.sender === OwnerAndManager[0].native || Txn.sender === OwnerAndManager[1].native
    swap
    retsub

isOwnerOrManagerCaller_bool_false@4:
    intc_0 // 0
    b isOwnerOrManagerCaller_bool_merge@5


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.checkIfBinClosed() -> void:
checkIfBinClosed:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1031
    // private checkIfBinClosed() {
    proto 0 0
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:1032
    // const currentBinSize = this.roundsPerDay.value
    dupn 5
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1032
    // const currentBinSize = this.roundsPerDay.value
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // smart_contracts/reti_prod/stakingPool.algo.ts:1033
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    global Round
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1033
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    >=
    bz checkIfBinClosed_after_if_else@9
    // smart_contracts/reti_prod/stakingPool.algo.ts:1034
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/reti_prod/stakingPool.algo.ts:1035
    // const approxRoundsPerYear = BigUint(currentBinSize * 365)
    frame_dig 5
    dup
    pushint 365 // 365
    *
    itob
    frame_bury 1
    // smart_contracts/reti_prod/stakingPool.algo.ts:1036
    // const avgStake = BigUint(this.stakeAccumulator.value.native / BigUint(currentBinSize))
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1036
    // const avgStake = BigUint(this.stakeAccumulator.value.native / BigUint(currentBinSize))
    app_global_get_ex
    assert // check GlobalState exists
    swap
    itob
    dup
    frame_bury 4
    b/
    dup
    frame_bury 3
    // smart_contracts/reti_prod/stakingPool.algo.ts:1037
    // if (avgStake !== 0n) {
    pushbytes 0x
    b!=
    bz checkIfBinClosed_after_if_else@8
    // smart_contracts/reti_prod/stakingPool.algo.ts:1043
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1043
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    app_global_get_ex
    assert // check GlobalState exists
    itob
    pushbytes 0x0f4240
    b*
    frame_dig 3
    dup
    cover 2
    b/
    // smart_contracts/reti_prod/stakingPool.algo.ts:1044
    // (approxRoundsPerYear / BigUint(currentBinSize))) /
    frame_dig 1
    frame_dig 4
    b/
    // smart_contracts/reti_prod/stakingPool.algo.ts:1043-1044
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //   (approxRoundsPerYear / BigUint(currentBinSize))) /
    b*
    // smart_contracts/reti_prod/stakingPool.algo.ts:1045
    // 100n,
    bytec 14 // 0x64
    // smart_contracts/reti_prod/stakingPool.algo.ts:1043-1045
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //   (approxRoundsPerYear / BigUint(currentBinSize))) /
    //   100n,
    b/
    frame_bury 2
    // smart_contracts/reti_prod/stakingPool.algo.ts:1048
    // let alpha = BigUint(10) // .1
    pushbytes 0x0a
    frame_bury 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:1050
    // if (avgStake > 300000000000n) {
    pushbytes 0x45d964b800
    b>
    bz checkIfBinClosed_after_if_else@4
    // smart_contracts/reti_prod/stakingPool.algo.ts:1051
    // alpha = BigUint(90) // .9
    pushbytes 0x5a
    frame_bury 0

checkIfBinClosed_after_if_else@4:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1055
    // if (this.weightedMovingAverage.value.native === 0n) {
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1055
    // if (this.weightedMovingAverage.value.native === 0n) {
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes 0x
    b==
    bz checkIfBinClosed_else_body@6
    // smart_contracts/reti_prod/stakingPool.algo.ts:1056
    // this.weightedMovingAverage.value = new Uint128(apr)
    frame_dig 2
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // smart_contracts/reti_prod/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1056
    // this.weightedMovingAverage.value = new Uint128(apr)
    swap
    app_global_put

checkIfBinClosed_after_if_else@8:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1066
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // smart_contracts/reti_prod/stakingPool.algo.ts:1067
    // this.stakeAccumulator.value = new Uint128(BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value))
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1067
    // this.stakeAccumulator.value = new Uint128(BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value))
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1067
    // this.stakeAccumulator.value = new Uint128(BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value))
    app_global_get_ex
    assert // check GlobalState exists
    itob
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // smart_contracts/reti_prod/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1067
    // this.stakeAccumulator.value = new Uint128(BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value))
    swap
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1068
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:1069
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    global Round
    dup
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1069
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // smart_contracts/reti_prod/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1069
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    swap
    app_global_put

checkIfBinClosed_after_if_else@9:
    retsub

checkIfBinClosed_else_body@6:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1059
    // (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    intc_0 // 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1059
    // (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    app_global_get_ex
    assert // check GlobalState exists
    bytec 14 // 0x64
    frame_dig 0
    dup
    cover 3
    b-
    b*
    bytec 14 // 0x64
    b/
    // smart_contracts/reti_prod/stakingPool.algo.ts:1060
    // (apr * alpha) / BigUint(100),
    frame_dig 2
    uncover 2
    b*
    bytec 14 // 0x64
    b/
    // smart_contracts/reti_prod/stakingPool.algo.ts:1059-1060
    // (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    //   (apr * alpha) / BigUint(100),
    b+
    // smart_contracts/reti_prod/stakingPool.algo.ts:1058-1061
    // this.weightedMovingAverage.value = new Uint128(
    //   (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    //     (apr * alpha) / BigUint(100),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // smart_contracts/reti_prod/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1058-1061
    // this.weightedMovingAverage.value = new Uint128(
    //   (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    //     (apr * alpha) / BigUint(100),
    // )
    swap
    app_global_put
    b checkIfBinClosed_after_if_else@8


// smart_contracts/reti_prod/stakingPool.algo.ts::StakingPool.setRoundsPerDay() -> void:
setRoundsPerDay:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1073
    // private setRoundsPerDay() {
    proto 0 0
    pushbytes ""
    // smart_contracts/reti_prod/stakingPool.algo.ts:1078
    // if (Txn.firstValid < 12) {
    txn FirstValid
    pushint 12 // 12
    <
    bz setRoundsPerDay_after_if_else@2
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1080
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:1081
    // return
    retsub

setRoundsPerDay_after_if_else@2:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1085
    // op.Block.blkTimestamp(Txn.firstValid - 1) - op.Block.blkTimestamp(Txn.firstValid - 11)
    txn FirstValid
    intc_1 // 1
    -
    block BlkTimestamp
    txn FirstValid
    pushint 11 // 11
    -
    block BlkTimestamp
    -
    dup
    frame_bury 0
    // smart_contracts/reti_prod/stakingPool.algo.ts:1086
    // if (avgBlockTimeTenths === 0) {
    bnz setRoundsPerDay_after_if_else@4
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1088
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // smart_contracts/reti_prod/stakingPool.algo.ts:1089
    // return
    retsub

setRoundsPerDay_after_if_else@4:
    // smart_contracts/reti_prod/stakingPool.algo.ts:1094
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    pushint 864000 // 864000
    frame_dig 0
    /
    // smart_contracts/reti_prod/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // smart_contracts/reti_prod/stakingPool.algo.ts:1094
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    swap
    app_global_put
    retsub
