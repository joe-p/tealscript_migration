#pragma version 11
intcblock 0 1 8 24 18 268 32 6 3 242 2 10 252 260 700 4 100000 900 16 200 40 72 192 244 1000000 4096 5 226 TMPL_nfdRegistryAppId 300 432 892 1000 28500 50000 11 80 145 153 209
bytecblock 0x76 0x 0x151f7c75 0x737073 0x7374616b6564 0x00 0x6e756d5374616b657273 0x0000000000000000 0x0a8101 0x706f6f6c54656d706c617465417070726f76616c4279746573 0x692e6f776e65722e61 0x6e756d56 0x696e6974 0x63f3f28b 0x12f4bd4b

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 7 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts/validatorRegistry.algo.ts:82
	// this.stakingPoolInitialized.value = false
	bytec 12 //  "init"
	intc 0 // 0
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts/validatorRegistry.algo.ts:83
	// this.numValidators.value = 0
	bytec 11 //  "numV"
	intc 0 // 0
	app_global_put

	// contracts/validatorRegistry.algo.ts:84
	// this.numStakers.value = 0
	bytec 6 //  "numStakers"
	intc 0 // 0
	app_global_put

	// contracts/validatorRegistry.algo.ts:85
	// this.totalAlgoStaked.value = 0
	bytec 4 //  "staked"
	intc 0 // 0
	app_global_put
	retsub

// initStakingContract(uint64)void
*abi_route_initStakingContract:
	// approvalProgramSize: uint64
	txna ApplicationArgs 1
	btoi

	// execute initStakingContract(uint64)void
	callsub initStakingContract
	intc 1 // 1
	return

// initStakingContract(approvalProgramSize: uint64): void
initStakingContract:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:90
	// this.stakingPoolApprovalProgram.create(approvalProgramSize)
	bytec 9 //  "poolTemplateApprovalBytes"
	frame_dig -1 // approvalProgramSize: uint64
	box_create
	pop
	retsub

// loadStakingContractData(uint64,byte[])void
*abi_route_loadStakingContractData:
	// data: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// offset: uint64
	txna ApplicationArgs 1
	btoi

	// execute loadStakingContractData(uint64,byte[])void
	callsub loadStakingContractData
	intc 1 // 1
	return

// loadStakingContractData(offset: uint64, data: bytes): void
loadStakingContractData:
	proto 2 0

	// contracts/validatorRegistry.algo.ts:94
	// assert(!this.stakingPoolInitialized.value)
	bytec 12 //  "init"
	app_global_get
	intc 0 // 0
	getbit
	!
	assert

	// contracts/validatorRegistry.algo.ts:95
	// this.stakingPoolApprovalProgram.replace(offset, data)
	bytec 9 //  "poolTemplateApprovalBytes"
	frame_dig -1 // offset: uint64
	frame_dig -2 // data: bytes
	box_replace
	retsub

// finalizeStakingContract()void
*abi_route_finalizeStakingContract:
	// execute finalizeStakingContract()void
	callsub finalizeStakingContract
	intc 1 // 1
	return

// finalizeStakingContract(): void
finalizeStakingContract:
	proto 0 0

	// contracts/validatorRegistry.algo.ts:99
	// this.stakingPoolInitialized.value = true
	bytec 12 //  "init"
	intc 1 // 1
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	intc 1 // 1
	return

// gas(): void
//
// gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
gas:
	proto 0 0
	retsub

// getMbrAmounts()(uint64,uint64,uint64,uint64)
*abi_route_getMbrAmounts:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getMbrAmounts()(uint64,uint64,uint64,uint64)
	callsub getMbrAmounts
	concat
	log
	intc 1 // 1
	return

// getMbrAmounts(): MbrAmounts
//
// Returns the MBR amounts needed for various actions:
// [
// addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
// addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
// poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
// addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
// ]
getMbrAmounts:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:120
	// return {
	//             addValidatorMbr: this.costForBoxStorage(1 /* v prefix */ + len<ValidatorIdType>() + len<ValidatorInfo>()),
	//             addPoolMbr: this.minBalanceForAccount(
	//                 1,
	//                 // we could calculate this directly by referencing the size of stakingPoolApprovalProgram but it would
	//                 // mean our callers would have to reference the box AND buy up i/o - so just go max on extra pages
	//                 3,
	//                 0,
	//                 0,
	//                 0,
	//                 StakingPool.schema.global.numUint,
	//                 StakingPool.schema.global.numByteSlice,
	//             ),
	//             poolInitMbr:
	//                 ALGORAND_ACCOUNT_MIN_BALANCE +
	//                 this.costForBoxStorage(7 /* 'stakers' name */ + len<StakedInfo>() * MAX_STAKERS_PER_POOL),
	//             addStakerMbr:
	//                 // how much to charge for first time a staker adds stake - since we add a tracking box per staker
	//                 this.costForBoxStorage(
	//                     3 /* 'sps' prefix */ + len<Address>() + len<ValidatorPoolKey>() * MAX_POOLS_PER_STAKER,
	//                 ), // size of key + all values
	//         }
	pushint 1101
	callsub costForBoxStorage
	itob
	intc 8 // 3
	intc 35 // 11
	intc 0 // 0
	dupn 2
	intc 8 // 3
	intc 1 // 1
	callsub minBalanceForAccount
	itob
	concat
	intc 16 // 100000
	pushint 12807
	callsub costForBoxStorage
	+
	itob
	concat
	pushint 179
	callsub costForBoxStorage
	itob
	concat
	retsub

// getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_getProtocolConstraints:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub getProtocolConstraints
	concat
	log
	intc 1 // 1
	return

// getProtocolConstraints(): Constraints
//
// Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
getProtocolConstraints:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:149
	// return {
	//             epochPayoutRoundsMin: MIN_EPOCH_LENGTH,
	//             epochPayoutRoundsMax: MAX_EPOCH_LENGTH,
	//             minPctToValidatorWFourDecimals: MIN_PCT_TO_VALIDATOR,
	//             maxPctToValidatorWFourDecimals: MAX_PCT_TO_VALIDATOR,
	//             minEntryStake: MIN_ALGO_STAKE_PER_POOL,
	//             maxAlgoPerPool: this.maxAlgoAllowedPerPool(),
	//             maxAlgoPerValidator: this.maxAllowedStake(),
	//             amtConsideredSaturated: this.algoSaturationLevel(),
	//             maxNodes: MAX_NODES,
	//             maxPoolsPerNode: MAX_POOLS_PER_NODE,
	//             maxStakersPerPool: MAX_STAKERS_PER_POOL,
	//         }
	pushbytes 0x000000000000000100000000000f4240000000000000000000000000000f424000000000000f4240
	callsub maxAlgoAllowedPerPool
	itob
	concat
	callsub maxAllowedStake
	itob
	concat
	callsub algoSaturationLevel
	itob
	concat
	pushbytes 0x0000000000000008
	concat
	pushbytes 0x0000000000000003
	concat
	pushbytes 0x00000000000000c8
	concat
	retsub

// getNumValidators()uint64
*abi_route_getNumValidators:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getNumValidators()uint64
	callsub getNumValidators
	itob
	concat
	log
	intc 1 // 1
	return

// getNumValidators(): uint64
//
// Returns the current number of validators
getNumValidators:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:169
	// return this.numValidators.value
	bytec 11 //  "numV"
	app_global_get
	retsub

// getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
*abi_route_getValidatorConfig:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	callsub getValidatorConfig
	concat
	log
	intc 1 // 1
	return

// getValidatorConfig(validatorId: ValidatorIdType): ValidatorConfig
getValidatorConfig:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:174
	// return this.validatorList(validatorId).value.config
	intc 0 // 0
	intc 9 // 242
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	retsub

// getValidatorState(uint64)(uint16,uint64,uint64,uint64)
*abi_route_getValidatorState:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorState(uint64)(uint16,uint64,uint64,uint64)
	callsub getValidatorState
	concat
	log
	intc 1 // 1
	return

// getValidatorState(validatorId: ValidatorIdType): ValidatorCurState
getValidatorState:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:179
	// return this.validatorList(validatorId).value.state
	intc 9 //  headOffset
	pushint 26
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	retsub

// getValidatorOwnerAndManager(uint64)(address,address)
*abi_route_getValidatorOwnerAndManager:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorOwnerAndManager(uint64)(address,address)
	callsub getValidatorOwnerAndManager
	concat
	log
	intc 1 // 1
	return

// getValidatorOwnerAndManager(validatorId: ValidatorIdType): [Address, Address]
getValidatorOwnerAndManager:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:184
	// return [
	//             this.validatorList(validatorId).value.config.owner,
	//             this.validatorList(validatorId).value.config.manager,
	//         ]
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	intc 20 // 40
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	concat
	retsub

// getPools(uint64)(uint64,uint16,uint64)[]
*abi_route_getPools:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPools(uint64)(uint64,uint16,uint64)[]
	callsub getPools
	dup
	len
	intc 4 // 18
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 1 // 1
	return

// getPools(validatorId: ValidatorIdType): PoolInfo[]
//
// Return list of all pools for this validator.
// @param {uint64} validatorId
// @return {PoolInfo[]} - array of pools
// Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns
getPools:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:198
	// retData: PoolInfo[] = []
	bytec 1 // 0x
	frame_bury 0 // retData: PoolInfo[]

	// contracts/validatorRegistry.algo.ts:199
	// poolSet = clone(this.validatorList(validatorId).value.pools)
	intc 5 //  headOffset
	intc 30 // 432
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 1 // poolSet: (uint64,uint16,uint64)[24]

	// contracts/validatorRegistry.algo.ts:200
	// for (let i = 0; i < poolSet.length; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_0:
	// contracts/validatorRegistry.algo.ts:200
	// i < poolSet.length
	frame_dig 2 // i: uint64
	intc 3 // 24
	<
	bz *for_0_end

	// *if0_condition
	// contracts/validatorRegistry.algo.ts:201
	// poolSet[i].poolAppId === 0
	frame_dig 1 // poolSet: (uint64,uint16,uint64)[24]
	frame_dig 2 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	b *for_0_end

*if0_end:
	// contracts/validatorRegistry.algo.ts:205
	// retData.push(poolSet[i])
	frame_dig 0 // retData: PoolInfo[]
	frame_dig 1 // poolSet: (uint64,uint16,uint64)[24]
	frame_dig 2 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 4 // 18
	extract3
	concat
	frame_bury 0 // retData: PoolInfo[]

*for_0_continue:
	// contracts/validatorRegistry.algo.ts:200
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_0

*for_0_end:
	// contracts/validatorRegistry.algo.ts:207
	// return retData
	frame_dig 0 // retData: PoolInfo[]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getPoolAppId(uint64,uint64)uint64
*abi_route_getPoolAppId:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// poolId: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPoolAppId(uint64,uint64)uint64
	callsub getPoolAppId
	itob
	concat
	log
	intc 1 // 1
	return

// getPoolAppId(validatorId: uint64, poolId: uint64): uint64
//
// getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
// want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
// (which contains reward tokens if being used) so that the amount available can be determined.
getPoolAppId:
	proto 2 1

	// contracts/validatorRegistry.algo.ts:217
	// assert(
	//             poolId !== 0 && poolId <= this.validatorList(validatorId).value.pools.length,
	//             'pool id must be between 1 and number of pools for this validator',
	//         )
	frame_dig -2 // poolId: uint64
	intc 0 // 0
	!=
	dup
	bz *skip_and0
	frame_dig -2 // poolId: uint64
	intc 3 // 24
	<=
	&&

*skip_and0:
	// pool id must be between 1 and number of pools for this validator
	assert

	// contracts/validatorRegistry.algo.ts:221
	// return this.validatorList(validatorId).value.pools[poolId - 1].poolAppId
	intc 5 //  headOffset
	frame_dig -2 // poolId: uint64
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: uint64
	itob
	concat
	cover 2
	box_extract
	btoi
	retsub

// getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)
*abi_route_getPoolInfo:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 24
	==

	// argument 0 (poolKey) for getPoolInfo must be a (uint64,uint64,uint64)
	assert

	// execute getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)
	callsub getPoolInfo
	concat
	log
	intc 1 // 1
	return

// getPoolInfo(poolKey: ValidatorPoolKey): PoolInfo
getPoolInfo:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:226
	// return this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1]
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 4 // 18
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	retsub

// getCurMaxStakePerPool(uint64)uint64
*abi_route_getCurMaxStakePerPool:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCurMaxStakePerPool(uint64)uint64
	callsub getCurMaxStakePerPool
	itob
	concat
	log
	intc 1 // 1
	return

// getCurMaxStakePerPool(validatorId: ValidatorIdType): uint64
//
// Calculate the maximum stake per pool for a given validator.
// Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
// as pools are added the max allowed per pool can reduce.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
getCurMaxStakePerPool:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:238
	// numPools = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // numPools: uint64

	// contracts/validatorRegistry.algo.ts:239
	// hardMaxDividedBetweenPools = this.maxAllowedStake() / numPools
	callsub maxAllowedStake
	frame_dig 0 // numPools: uint64
	/
	frame_bury 1 // hardMaxDividedBetweenPools: uint64

	// contracts/validatorRegistry.algo.ts:240
	// maxPerPool: uint64 = this.validatorList(validatorId).value.config.maxAlgoPerPool
	pushint 217
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // maxPerPool: uint64

	// *if1_condition
	// contracts/validatorRegistry.algo.ts:241
	// maxPerPool === 0
	frame_dig 2 // maxPerPool: uint64
	intc 0 // 0
	==
	bz *if1_end

	// *if1_consequent
	// contracts/validatorRegistry.algo.ts:242
	// maxPerPool = this.maxAlgoAllowedPerPool()
	callsub maxAlgoAllowedPerPool
	frame_bury 2 // maxPerPool: uint64

*if1_end:
	// *if2_condition
	// contracts/validatorRegistry.algo.ts:244
	// hardMaxDividedBetweenPools < maxPerPool
	frame_dig 1 // hardMaxDividedBetweenPools: uint64
	frame_dig 2 // maxPerPool: uint64
	<
	bz *if2_end

	// *if2_consequent
	// contracts/validatorRegistry.algo.ts:245
	// maxPerPool = hardMaxDividedBetweenPools
	frame_dig 1 // hardMaxDividedBetweenPools: uint64
	frame_bury 2 // maxPerPool: uint64

*if2_end:
	// contracts/validatorRegistry.algo.ts:247
	// return maxPerPool
	frame_dig 2 // maxPerPool: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// doesStakerNeedToPayMBR(address)bool
*abi_route_doesStakerNeedToPayMBR:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 0 (staker) for doesStakerNeedToPayMBR must be a address
	assert

	// execute doesStakerNeedToPayMBR(address)bool
	callsub doesStakerNeedToPayMBR
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// doesStakerNeedToPayMBR(staker: Address): boolean
//
// Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
// @param staker
doesStakerNeedToPayMBR:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:256
	// return !this.stakerPoolSet(staker).exists
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	!
	retsub

// getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]
*abi_route_getStakedPoolsForAccount:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	intc 6 // 32
	==

	// argument 0 (staker) for getStakedPoolsForAccount must be a address
	assert

	// execute getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]
	callsub getStakedPoolsForAccount
	dup
	len
	intc 3 // 24
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 1 // 1
	return

// getStakedPoolsForAccount(staker: Address): ValidatorPoolKey[]
//
// Retrieves the staked pools for an account.
//
// @param {Address} staker - The account to retrieve staked pools for.
// @return {ValidatorPoolKey[]} - The array of staked pools for the account.
getStakedPoolsForAccount:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// *if3_condition
	// contracts/validatorRegistry.algo.ts:267
	// !this.stakerPoolSet(staker).exists
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	!
	bz *if3_end

	// *if3_consequent
	// contracts/validatorRegistry.algo.ts:268
	// return []
	bytec 1 // 0x
	b *getStakedPoolsForAccount*return

*if3_end:
	// contracts/validatorRegistry.algo.ts:270
	// retData: ValidatorPoolKey[] = []
	bytec 1 // 0x
	frame_bury 0 // retData: ValidatorPoolKey[]

	// contracts/validatorRegistry.algo.ts:271
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 1 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:272
	// for (let i = 0; i < poolSet.length; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_1:
	// contracts/validatorRegistry.algo.ts:272
	// i < poolSet.length
	frame_dig 2 // i: uint64
	intc 7 // 6
	<
	bz *for_1_end

	// *if4_condition
	// contracts/validatorRegistry.algo.ts:273
	// poolSet[i].id !== 0
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	!=
	bz *if4_end

	// *if4_consequent
	// contracts/validatorRegistry.algo.ts:274
	// retData.push(poolSet[i])
	frame_dig 0 // retData: ValidatorPoolKey[]
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	concat
	frame_bury 0 // retData: ValidatorPoolKey[]

*if4_end:

*for_1_continue:
	// contracts/validatorRegistry.algo.ts:272
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_1

*for_1_end:
	// contracts/validatorRegistry.algo.ts:277
	// return retData
	frame_dig 0 // retData: ValidatorPoolKey[]

*getStakedPoolsForAccount*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getTokenPayoutRatio(uint64)(uint64[24],uint64)
*abi_route_getTokenPayoutRatio:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getTokenPayoutRatio(uint64)(uint64[24],uint64)
	callsub getTokenPayoutRatio
	concat
	log
	intc 1 // 1
	return

// getTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio
//
// Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
// payouts across pools can be based on a stable snaphost of stake.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @return {PoolTokenPayoutRatio} - The token payout ratio for the validator.
getTokenPayoutRatio:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:289
	// return this.validatorList(validatorId).value.tokenPayoutRatio
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	retsub

// getNodePoolAssignments(uint64)((uint64[3])[8])
*abi_route_getNodePoolAssignments:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNodePoolAssignments(uint64)((uint64[3])[8])
	callsub getNodePoolAssignments
	concat
	log
	intc 1 // 1
	return

// getNodePoolAssignments(validatorId: uint64): NodePoolAssignmentConfig
getNodePoolAssignments:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:294
	// assert(this.validatorList(validatorId).exists, "the specified validator id doesn't exist")
	bytec 0 //  "v"
	frame_dig -1 // validatorId: uint64
	itob
	concat
	box_len
	swap
	pop

	// the specified validator id doesn't exist
	assert

	// contracts/validatorRegistry.algo.ts:296
	// return this.validatorList(validatorId).value.nodePoolAssignments
	intc 17 //  headOffset
	intc 22 // 192
	bytec 0 //  "v"
	frame_dig -1 // validatorId: uint64
	itob
	concat
	cover 2
	box_extract
	retsub

// getNFDRegistryID()uint64
*abi_route_getNFDRegistryID:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// execute getNFDRegistryID()uint64
	callsub getNFDRegistryID
	itob
	concat
	log
	intc 1 // 1
	return

// getNFDRegistryID(): uint64
getNFDRegistryID:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:301
	// return this.nfdRegistryAppId
	intc 28 // TMPL_nfdRegistryAppId
	retsub

// addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64
*abi_route_addValidator:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	txna ApplicationArgs 2
	dup
	len
	intc 9 // 242
	==

	// argument 0 (config) for addValidator must be a (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	assert

	// nfdName: string
	txna ApplicationArgs 1
	extract 2 0

	// mbrPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (mbrPayment) for addValidator must be a pay transaction
	assert

	// execute addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64
	callsub addValidator
	itob
	concat
	log
	intc 1 // 1
	return

// addValidator(mbrPayment: PayTxn, nfdName: string, config: ValidatorConfig): uint64
//
// Adds a new validator
// Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.
//
// @param {PayTxn} mbrPayment payment from caller which covers mbr increase of new validator storage
// @param {string} nfdName (Optional) Name of nfd (used as double-check against id specified in config)
// @param {ValidatorConfig} config ValidatorConfig struct
// @returns {uint64} validator id
addValidator:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/validatorRegistry.algo.ts:313
	// this.validateConfig(config)
	frame_dig -3 // config: ValidatorConfig
	callsub validateConfig

	// contracts/validatorRegistry.algo.ts:315
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: this.getMbrAmounts().addValidatorMbr })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	callsub getMbrAmounts
	extract 0 8
	btoi
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"this.getMbrAmounts().addValidatorMbr"}
	assert

	// contracts/validatorRegistry.algo.ts:317
	// assert(mbrPayment.fee > 10 * 1000000, 'fee must be 10 ALGO or more to prevent spamming of validators')
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Fee
	pushint 10000000
	>

	// fee must be 10 ALGO or more to prevent spamming of validators
	assert

	// contracts/validatorRegistry.algo.ts:320
	// validatorId = this.numValidators.value + 1
	bytec 11 //  "numV"
	app_global_get
	intc 1 // 1
	+
	frame_bury 0 // validatorId: uint64

	// contracts/validatorRegistry.algo.ts:321
	// this.numValidators.value = validatorId
	bytec 11 //  "numV"
	frame_dig 0 // validatorId: uint64
	app_global_put

	// contracts/validatorRegistry.algo.ts:323
	// this.validatorList(validatorId).create()
	bytec 0 //  "v"
	frame_dig 0 // validatorId: uint64
	itob
	concat
	pushint 1092
	box_create
	pop

	// contracts/validatorRegistry.algo.ts:324
	// this.validatorList(validatorId).value.config = config
	intc 0 // 0
	frame_dig -3 // config: ValidatorConfig
	bytec 0 //  "v"
	frame_dig 0 // validatorId: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:325
	// this.validatorList(validatorId).value.config.id = validatorId
	intc 0 // 0
	frame_dig 0 // validatorId: uint64
	itob
	bytec 0 //  "v"
	frame_dig 0 // validatorId: uint64
	itob
	concat
	cover 2
	box_replace

	// *if5_condition
	// contracts/validatorRegistry.algo.ts:328
	// config.nfdForInfo !== 0
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	intc 0 // 0
	!=
	bz *if5_end

	// *if5_consequent
	// contracts/validatorRegistry.algo.ts:330
	// assert(this.isNFDAppIDValid(config.nfdForInfo), 'provided NFD must be valid')
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	callsub isNFDAppIDValid

	// provided NFD must be valid
	assert

	// contracts/validatorRegistry.algo.ts:332
	// assert(
	//                 this.txn.sender === (AppID.fromUint64(config.nfdForInfo).globalState('i.owner.a') as Address),
	//                 'If specifying NFD, account adding validator must be owner',
	//             )
	txn Sender
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(config.nfdForInfo).globalState('i.owner.a')
	assert
	==

	// If specifying NFD, account adding validator must be owner
	assert

*if5_end:
	// *if6_condition
	// contracts/validatorRegistry.algo.ts:338
	// config.entryGatingType === GATING_TYPE_CREATED_BY_NFD_ADDRESSES ||
	//             config.entryGatingType === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig -3 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 8 // 3
	==
	dup
	bnz *skip_or0
	frame_dig -3 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 15 // 4
	==
	||

*skip_or0:
	bz *if6_end

	// *if6_consequent
	// contracts/validatorRegistry.algo.ts:342
	// assert(
	//                 this.isNFDAppIDValid(config.entryGatingAssets[0]),
	//                 'provided NFD App id for gating must be valid NFD',
	//             )
	frame_dig -3 // config: ValidatorConfig
	extract 113 8
	btoi
	callsub isNFDAppIDValid

	// provided NFD App id for gating must be valid NFD
	assert

*if6_end:
	// contracts/validatorRegistry.algo.ts:347
	// this.retiOP_addedValidator.log({ id: validatorId, owner: config.owner, manager: config.manager })
	pushbytes 0xa8dd21cb // retiOP_addedValidator(uint64,address,address)
	frame_dig 0 // validatorId: uint64
	itob
	frame_dig -3 // config: ValidatorConfig
	extract 8 32
	concat
	frame_dig -3 // config: ValidatorConfig
	extract 40 32
	concat
	concat
	log

	// contracts/validatorRegistry.algo.ts:348
	// return validatorId
	frame_dig 0 // validatorId: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// changeValidatorManager(uint64,address)void
*abi_route_changeValidatorManager:
	// manager: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 0 (manager) for changeValidatorManager must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorManager(uint64,address)void
	callsub changeValidatorManager
	intc 1 // 1
	return

// changeValidatorManager(validatorId: ValidatorIdType, manager: Address): void
//
// Changes the Validator manager for a specific Validator id.
// [ ONLY OWNER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator to change the manager for.
// @param {Address} manager - The new manager address.
changeValidatorManager:
	proto 2 0

	// contracts/validatorRegistry.algo.ts:359
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// contracts/validatorRegistry.algo.ts:360
	// assert(manager !== globals.zeroAddress, 'needs to at least be valid address')
	frame_dig -2 // manager: Address
	global ZeroAddress
	!=

	// needs to at least be valid address
	assert

	// contracts/validatorRegistry.algo.ts:361
	// this.validatorList(validatorId).value.config.manager = manager
	intc 20 // 40
	frame_dig -2 // manager: Address
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorSunsetInfo(uint64,uint64,uint64)void
*abi_route_changeValidatorSunsetInfo:
	// sunsettingTo: uint64
	txna ApplicationArgs 3
	btoi

	// sunsettingOn: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorSunsetInfo(uint64,uint64,uint64)void
	callsub changeValidatorSunsetInfo
	intc 1 // 1
	return

// changeValidatorSunsetInfo(validatorId: ValidatorIdType, sunsettingOn: uint64, sunsettingTo: ValidatorIdType): void
//
// Updates the sunset information for a given validator.
// [ ONLY OWNER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator to update.
// @param {uint64} sunsettingOn - The new sunset timestamp.
// @param {uint64} sunsettingTo - The new sunset to validator id.
changeValidatorSunsetInfo:
	proto 3 0

	// contracts/validatorRegistry.algo.ts:373
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// contracts/validatorRegistry.algo.ts:374
	// this.validatorList(validatorId).value.config.sunsettingOn = sunsettingOn
	intc 27 // 226
	frame_dig -2 // sunsettingOn: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:375
	// this.validatorList(validatorId).value.config.sunsettingTo = sunsettingTo
	pushint 234
	frame_dig -3 // sunsettingTo: ValidatorIdType
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorNFD(uint64,uint64,string)void
*abi_route_changeValidatorNFD:
	// nfdName: string
	txna ApplicationArgs 3
	extract 2 0

	// nfdAppID: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorNFD(uint64,uint64,string)void
	callsub changeValidatorNFD
	intc 1 // 1
	return

// changeValidatorNFD(validatorId: ValidatorIdType, nfdAppID: uint64, nfdName: string): void
//
// Changes the NFD for a validator in the validatorList contract.
// [ ONLY OWNER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator to update.
// @param {uint64} nfdAppID - The application id of the NFD to assign to the validator.
// @param {string} nfdName - The name of the NFD (which must match)
changeValidatorNFD:
	proto 3 0

	// contracts/validatorRegistry.algo.ts:387
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// contracts/validatorRegistry.algo.ts:389
	// assert(this.isNFDAppIDValid(nfdAppID), 'provided NFD must be valid')
	frame_dig -2 // nfdAppID: uint64
	callsub isNFDAppIDValid

	// provided NFD must be valid
	assert

	// contracts/validatorRegistry.algo.ts:391
	// assert(
	//             this.txn.sender === (AppID.fromUint64(nfdAppID).globalState('i.owner.a') as Address),
	//             'If specifying NFD, account adding validator must be owner',
	//         )
	txn Sender
	frame_dig -2 // nfdAppID: uint64
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.owner.a')
	assert
	==

	// If specifying NFD, account adding validator must be owner
	assert

	// contracts/validatorRegistry.algo.ts:395
	// this.validatorList(validatorId).value.config.nfdForInfo = nfdAppID
	intc 21 // 72
	frame_dig -2 // nfdAppID: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorCommissionAddress(uint64,address)void
*abi_route_changeValidatorCommissionAddress:
	// commissionAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 0 (commissionAddress) for changeValidatorCommissionAddress must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorCommissionAddress(uint64,address)void
	callsub changeValidatorCommissionAddress
	intc 1 // 1
	return

// changeValidatorCommissionAddress(validatorId: ValidatorIdType, commissionAddress: Address): void
//
// Change the commission address that validator rewards are sent to.
// [ ONLY OWNER CAN CHANGE ]
changeValidatorCommissionAddress:
	proto 2 0

	// contracts/validatorRegistry.algo.ts:403
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// contracts/validatorRegistry.algo.ts:404
	// assert(commissionAddress !== Address.zeroAddress)
	frame_dig -2 // commissionAddress: Address
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:405
	// this.validatorList(validatorId).value.config.validatorCommissionAddress = commissionAddress
	pushint 177
	frame_dig -2 // commissionAddress: Address
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void
*abi_route_changeValidatorRewardInfo:
	// RewardPerPayout: uint64
	txna ApplicationArgs 6
	btoi

	// GatingAssetMinBalance: uint64
	txna ApplicationArgs 5
	btoi

	// EntryGatingAssets: uint64[4]
	txna ApplicationArgs 4
	dup
	len
	intc 6 // 32
	==

	// argument 2 (EntryGatingAssets) for changeValidatorRewardInfo must be a uint64[4]
	assert

	// EntryGatingAddress: address
	txna ApplicationArgs 3
	dup
	len
	intc 6 // 32
	==

	// argument 3 (EntryGatingAddress) for changeValidatorRewardInfo must be a address
	assert

	// EntryGatingType: uint8
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 4 (EntryGatingType) for changeValidatorRewardInfo must be a uint8
	assert
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void
	callsub changeValidatorRewardInfo
	intc 1 // 1
	return

// changeValidatorRewardInfo(validatorId: ValidatorIdType, EntryGatingType: uint8, EntryGatingAddress: Address, EntryGatingAssets: StaticArray<uint64, 4>, GatingAssetMinBalance: uint64, RewardPerPayout: uint64): void
//
// Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
// [ ONLY OWNER CAN CHANGE ]
changeValidatorRewardInfo:
	proto 6 0

	// contracts/validatorRegistry.algo.ts:420
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// contracts/validatorRegistry.algo.ts:422
	// assert(
	//             EntryGatingType >= GATING_TYPE_NONE && EntryGatingType < GATING_TYPE_CONST_MAX,
	//             'invalid Entry gating type',
	//         )
	frame_dig -2 // EntryGatingType: uint8
	intc 0 // 0
	>=
	dup
	bz *skip_and1
	frame_dig -2 // EntryGatingType: uint8
	intc 15 // 4
	<
	&&

*skip_and1:
	// invalid Entry gating type
	assert

	// *if7_condition
	// contracts/validatorRegistry.algo.ts:426
	// EntryGatingType === GATING_TYPE_ASSETS_CREATED_BY
	frame_dig -2 // EntryGatingType: uint8
	intc 1 // 1
	==
	bz *if7_end

	// *if7_consequent
	// contracts/validatorRegistry.algo.ts:427
	// assert(EntryGatingAddress !== globals.zeroAddress)
	frame_dig -3 // EntryGatingAddress: Address
	global ZeroAddress
	!=
	assert

*if7_end:
	// *if8_condition
	// contracts/validatorRegistry.algo.ts:430
	// EntryGatingType === GATING_TYPE_CREATED_BY_NFD_ADDRESSES ||
	//             EntryGatingType === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig -2 // EntryGatingType: uint8
	intc 8 // 3
	==
	dup
	bnz *skip_or1
	frame_dig -2 // EntryGatingType: uint8
	intc 15 // 4
	==
	||

*skip_or1:
	bz *if8_end

	// *if8_consequent
	// contracts/validatorRegistry.algo.ts:433
	// assert(this.isNFDAppIDValid(EntryGatingAssets[0]), 'provided NFD App id for gating must be valid NFD')
	frame_dig -4 // EntryGatingAssets: StaticArray<uint64, 4>
	extract 0 8
	btoi
	callsub isNFDAppIDValid

	// provided NFD App id for gating must be valid NFD
	assert

*if8_end:
	// contracts/validatorRegistry.algo.ts:435
	// this.validatorList(validatorId).value.config.entryGatingType = EntryGatingType
	intc 36 // 80
	frame_dig -2 // EntryGatingType: uint8
	itob
	extract 7 1
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:436
	// this.validatorList(validatorId).value.config.entryGatingAddress = EntryGatingAddress
	pushint 81
	frame_dig -3 // EntryGatingAddress: Address
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:437
	// this.validatorList(validatorId).value.config.entryGatingAssets = EntryGatingAssets
	pushint 113
	frame_dig -4 // EntryGatingAssets: StaticArray<uint64, 4>
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:438
	// this.validatorList(validatorId).value.config.gatingAssetMinBalance = GatingAssetMinBalance
	intc 37 // 145
	frame_dig -5 // GatingAssetMinBalance: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:439
	// this.validatorList(validatorId).value.config.rewardPerPayout = RewardPerPayout
	pushint 161
	frame_dig -6 // RewardPerPayout: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace
	retsub

// addPool(pay,uint64,uint64)(uint64,uint64,uint64)
*abi_route_addPool:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// nodeNum: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// mbrPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (mbrPayment) for addPool must be a pay transaction
	assert

	// execute addPool(pay,uint64,uint64)(uint64,uint64,uint64)
	callsub addPool
	concat
	log
	intc 1 // 1
	return

// addPool(mbrPayment: PayTxn, validatorId: ValidatorIdType, nodeNum: uint64): ValidatorPoolKey
//
// Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
// The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
//
// [ ONLY OWNER OR MANAGER CAN call ]
// @param {PayTxn} mbrPayment payment from caller which covers mbr increase of adding a new pool
// @param {uint64} validatorId is id of validator to pool to (must be owner or manager)
// @param {uint64} nodeNum is node number to add to
// @returns {ValidatorPoolKey} pool key to created pool
addPool:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/validatorRegistry.algo.ts:454
	// this.callerMustBeOwnerOrManager(validatorId)
	frame_dig -2 // validatorId: ValidatorIdType
	callsub callerMustBeOwnerOrManager

	// contracts/validatorRegistry.algo.ts:457
	// verifyPayTxn(mbrPayment, { receiver: this.app.address, amount: this.getMbrAmounts().addPoolMbr })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	callsub getMbrAmounts
	extract 8 8
	btoi
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"this.getMbrAmounts().addPoolMbr"}
	assert

	// contracts/validatorRegistry.algo.ts:459
	// assert(this.validatorList(validatorId).exists, "specified validator id isn't valid")
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	box_len
	swap
	pop

	// specified validator id isn't valid
	assert

	// contracts/validatorRegistry.algo.ts:461
	// numPools: uint64 = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // numPools: uint64

	// *if9_condition
	// contracts/validatorRegistry.algo.ts:462
	// (numPools as uint64) >= MAX_POOLS
	frame_dig 0 // numPools: uint64
	intc 3 // 24
	>=
	bz *if9_end

	// *if9_consequent
	// already at max pool size
	err

*if9_end:
	// contracts/validatorRegistry.algo.ts:465
	// numPools += 1
	frame_dig 0 // numPools: uint64
	intc 1 // 1
	+
	frame_bury 0 // numPools: uint64

	// contracts/validatorRegistry.algo.ts:468
	// sendAppCall({
	//             onCompletion: OnCompletion.NoOp,
	//             approvalProgram: [
	//                 this.stakingPoolApprovalProgram.extract(0, 4096),
	//                 this.stakingPoolApprovalProgram.extract(4096, this.stakingPoolApprovalProgram.size - 4096),
	//             ],
	//             clearStateProgram: StakingPool.clearProgram(),
	//             globalNumUint: StakingPool.schema.global.numUint,
	//             globalNumByteSlice: StakingPool.schema.global.numByteSlice,
	//             extraProgramPages: 3,
	//             applicationArgs: [
	//                 // creatingContractID, validatorId, poolId, minEntryStake
	//                 method('createApplication(uint64,uint64,uint64,uint64)void'),
	//                 itob(this.app.id),
	//                 itob(validatorId),
	//                 itob(numPools as uint64),
	//                 itob(this.validatorList(validatorId).value.config.minEntryStake),
	//             ],
	//         })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:469
	// onCompletion: OnCompletion.NoOp
	intc 0 //  NoOp
	itxn_field OnCompletion

	// contracts/validatorRegistry.algo.ts:470
	// approvalProgram: [
	//                 this.stakingPoolApprovalProgram.extract(0, 4096),
	//                 this.stakingPoolApprovalProgram.extract(4096, this.stakingPoolApprovalProgram.size - 4096),
	//             ]
	bytec 9 //  "poolTemplateApprovalBytes"
	intc 0 // 0
	intc 25 // 4096
	box_extract
	itxn_field ApprovalProgramPages
	bytec 9 //  "poolTemplateApprovalBytes"
	intc 25 // 4096
	bytec 9 //  "poolTemplateApprovalBytes"
	box_len

	// box value does not exist: this.stakingPoolApprovalProgram.size
	assert
	intc 25 // 4096
	-
	box_extract
	itxn_field ApprovalProgramPages

	// contracts/validatorRegistry.algo.ts:474
	// clearStateProgram: StakingPool.clearProgram()
	pushbytes 0x0b
	itxn_field ClearStateProgram

	// contracts/validatorRegistry.algo.ts:475
	// globalNumUint: StakingPool.schema.global.numUint
	intc 35 // 11
	itxn_field GlobalNumUint

	// contracts/validatorRegistry.algo.ts:476
	// globalNumByteSlice: StakingPool.schema.global.numByteSlice
	intc 8 // 3
	itxn_field GlobalNumByteSlice

	// contracts/validatorRegistry.algo.ts:477
	// extraProgramPages: 3
	intc 8 // 3
	itxn_field ExtraProgramPages

	// contracts/validatorRegistry.algo.ts:478
	// applicationArgs: [
	//                 // creatingContractID, validatorId, poolId, minEntryStake
	//                 method('createApplication(uint64,uint64,uint64,uint64)void'),
	//                 itob(this.app.id),
	//                 itob(validatorId),
	//                 itob(numPools as uint64),
	//                 itob(this.validatorList(validatorId).value.config.minEntryStake),
	//             ]
	pushbytes 0x59e90aa6 // method "createApplication(uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs
	txna Applications 0
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	itxn_field ApplicationArgs
	frame_dig 0 // numPools: uint64
	itob
	itxn_field ApplicationArgs
	intc 39 // 209
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:488
	// this.validatorList(validatorId).value.state.numPools = numPools as uint16
	intc 9 // 242
	frame_dig 0 // numPools: uint64
	itob
	extract 6 2
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:491
	// poolAppId = this.itxn.createdApplicationID.id
	itxn CreatedApplicationID
	frame_bury 1 // poolAppId: uint64

	// contracts/validatorRegistry.algo.ts:492
	// this.validatorList(validatorId).value.pools[numPools - 1].poolAppId = poolAppId
	intc 5 //  headOffset
	frame_dig 0 // numPools: uint64
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 1 // poolAppId: uint64
	itob
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:493
	// this.addPoolToNode(validatorId, poolAppId, nodeNum)
	frame_dig -3 // nodeNum: uint64
	frame_dig 1 // poolAppId: uint64
	frame_dig -2 // validatorId: ValidatorIdType
	callsub addPoolToNode

	// contracts/validatorRegistry.algo.ts:495
	// this.retiOP_validatorAddedPool.log({
	//             id: validatorId,
	//             num: numPools as uint16,
	//             poolAppId: AppID.fromUint64(poolAppId),
	//         })
	pushbytes 0xfbcc0f6b // retiOP_validatorAddedPool(uint64,uint16,uint64)
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	frame_dig 0 // numPools: uint64
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// numPools as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig 1 // poolAppId: uint64
	itob
	concat
	concat
	log

	// contracts/validatorRegistry.algo.ts:501
	// return { id: validatorId, poolId: numPools as uint64, poolAppId: this.itxn!.createdApplicationID.id }
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	frame_dig 0 // numPools: uint64
	itob
	concat
	itxn CreatedApplicationID
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// addStake(pay,uint64,uint64)(uint64,uint64,uint64)
*abi_route_addStake:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// valueToVerify: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// stakedAmountPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (stakedAmountPayment) for addStake must be a pay transaction
	assert

	// execute addStake(pay,uint64,uint64)(uint64,uint64,uint64)
	callsub addStake
	concat
	log
	intc 1 // 1
	return

// addStake(stakedAmountPayment: PayTxn, validatorId: ValidatorIdType, valueToVerify: uint64): ValidatorPoolKey
//
// Adds stake to a validator pool.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {uint64} valueToVerify - only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.
// Txn sender is factored in as well if that is part of gating.
// * @returns {ValidatorPoolKey} - The key of the validator pool.
addStake:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 5

	// contracts/validatorRegistry.algo.ts:514
	// assert(this.validatorList(validatorId).exists, "specified validator id isn't valid")
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	box_len
	swap
	pop

	// specified validator id isn't valid
	assert

	// *if10_condition
	// contracts/validatorRegistry.algo.ts:517
	// this.validatorList(validatorId).value.config.sunsettingOn > 0
	intc 27 // 226
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	>
	bz *if10_end

	// *if10_consequent
	// contracts/validatorRegistry.algo.ts:519
	// assert(
	//                 this.validatorList(validatorId).value.config.sunsettingOn > globals.latestTimestamp,
	//                 "can't stake with a validator that is past its sunsetting time",
	//             )
	intc 27 // 226
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	global LatestTimestamp
	>

	// can't stake with a validator that is past its sunsetting time
	assert

*if10_end:
	// contracts/validatorRegistry.algo.ts:525
	// staker = this.txn.sender
	txn Sender
	frame_bury 0 // staker: address

	// contracts/validatorRegistry.algo.ts:529
	// verifyPayTxn(stakedAmountPayment, {
	//             sender: staker,
	//             receiver: this.app.address,
	//         })
	// verify sender
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	frame_dig 0 // staker: address
	==

	// transaction verification failed: {"txn":"stakedAmountPayment","field":"sender","expected":"staker"}
	assert

	// verify receiver
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakedAmountPayment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/validatorRegistry.algo.ts:537
	// this.doesStakerMeetGating(validatorId, valueToVerify)
	frame_dig -3 // valueToVerify: uint64
	frame_dig -2 // validatorId: ValidatorIdType
	callsub doesStakerMeetGating

	// contracts/validatorRegistry.algo.ts:539
	// realAmount = stakedAmountPayment.amount
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_bury 1 // realAmount: uint64

	// contracts/validatorRegistry.algo.ts:540
	// mbrAmtLeftBehind: uint64 = 0
	intc 0 // 0
	frame_bury 2 // mbrAmtLeftBehind: uint64

	// *if11_condition
	// contracts/validatorRegistry.algo.ts:542
	// this.doesStakerNeedToPayMBR(staker)
	frame_dig 0 // staker: address
	callsub doesStakerNeedToPayMBR
	bz *if11_end

	// *if11_consequent
	// contracts/validatorRegistry.algo.ts:545
	// mbrAmtLeftBehind = this.getMbrAmounts().addStakerMbr
	callsub getMbrAmounts
	extract 24 8
	btoi
	frame_bury 2 // mbrAmtLeftBehind: uint64

	// contracts/validatorRegistry.algo.ts:546
	// realAmount -= mbrAmtLeftBehind
	frame_dig 1 // realAmount: uint64
	frame_dig 2 // mbrAmtLeftBehind: uint64
	-
	frame_bury 1 // realAmount: uint64

	// contracts/validatorRegistry.algo.ts:547
	// this.stakerPoolSet(staker).create()
	bytec 3 //  "sps"
	frame_dig 0 // staker: address
	concat
	pushint 144
	box_create
	pop

*if11_end:
	// contracts/validatorRegistry.algo.ts:551
	// assert(
	//             this.validatorList(validatorId).value.state.totalAlgoStaked + realAmount < this.maxAllowedStake(),
	//             'total staked for all of a validators pools may not exceed hard cap',
	//         )
	intc 12 // 252
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig 1 // realAmount: uint64
	+
	callsub maxAllowedStake
	<

	// total staked for all of a validators pools may not exceed hard cap
	assert

	// contracts/validatorRegistry.algo.ts:558
	// findRet = this.findPoolForStaker(validatorId, staker, realAmount)
	frame_dig 1 // realAmount: uint64
	frame_dig 0 // staker: address
	frame_dig -2 // validatorId: ValidatorIdType
	callsub findPoolForStaker
	frame_bury 3 // findRet: ((uint64,uint64,uint64),bool,bool)

	// contracts/validatorRegistry.algo.ts:559
	// poolKey = findRet[0]
	// contracts/validatorRegistry.algo.ts:560
	// isNewStakerToValidator = findRet[1]
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	intc 22 // 192
	getbit
	frame_bury 4 // isNewStakerToValidator: bool

	// contracts/validatorRegistry.algo.ts:561
	// isNewStakerToProtocol = findRet[2]
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	pushint 193
	getbit
	frame_bury 5 // isNewStakerToProtocol: bool

	// *if12_condition
	// contracts/validatorRegistry.algo.ts:562
	// poolKey.poolId === 0
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	intc 0 // 0
	==
	bz *if12_end

	// *if12_consequent
	// No pool available with free stake.  Validator needs to add another pool
	err

*if12_end:
	// contracts/validatorRegistry.algo.ts:567
	// this.updateStakerPoolSet(staker, poolKey)
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24
	frame_dig 0 // staker: address
	callsub updateStakerPoolSet

	// contracts/validatorRegistry.algo.ts:570
	// this.callPoolAddStake(
	//             stakedAmountPayment,
	//             poolKey,
	//             mbrAmtLeftBehind,
	//             isNewStakerToValidator,
	//             isNewStakerToProtocol,
	//         )
	frame_dig 5 // isNewStakerToProtocol: bool
	frame_dig 4 // isNewStakerToValidator: bool
	frame_dig 2 // mbrAmtLeftBehind: uint64
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24
	frame_dig -1 // stakedAmountPayment: PayTxn
	callsub callPoolAddStake

	// contracts/validatorRegistry.algo.ts:577
	// this.retiOP_stakeAdded.log({
	//             id: validatorId,
	//             poolNum: poolKey.poolId as uint16,
	//             poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//             amountStaked: realAmount,
	//             staker: staker,
	//         })
	pushbytes 0x962b4143 // retiOP_stakeAdded(uint64,uint16,uint64,address,uint64)
	frame_dig -2 // validatorId: ValidatorIdType
	itob
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	itob
	concat
	frame_dig 0 // staker: address
	concat
	frame_dig 1 // realAmount: uint64
	itob
	concat
	concat
	log

	// contracts/validatorRegistry.algo.ts:585
	// return poolKey
	frame_dig 3 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

// setTokenPayoutRatio(uint64)(uint64[24],uint64)
*abi_route_setTokenPayoutRatio:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute setTokenPayoutRatio(uint64)(uint64[24],uint64)
	callsub setTokenPayoutRatio
	concat
	log
	intc 1 // 1
	return

// setTokenPayoutRatio(validatorId: ValidatorIdType): PoolTokenPayoutRatio
//
// setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
// of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
// in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
// pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
// It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
// their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
// during the epoch updates across pools)
//
// Multiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple
// times in same epoch.  Just return.
//
// @param validatorId - validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator.
// @returns PoolTokenPayoutRatio - the finished ratio data
setTokenPayoutRatio:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 8

	// contracts/validatorRegistry.algo.ts:605
	// pool1AppID = this.validatorList(validatorId).value.pools[0].poolAppId
	intc 5 // 268
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // pool1AppID: uint64

	// contracts/validatorRegistry.algo.ts:606
	// assert(pool1AppID !== 0)
	frame_dig 0 // pool1AppID: uint64
	intc 0 // 0
	!=
	assert

	// *if13_condition
	// contracts/validatorRegistry.algo.ts:608
	// this.txn.sender !== AppID.fromUint64(pool1AppID).address
	txn Sender
	frame_dig 0 // pool1AppID: uint64
	app_params_get AppAddress
	pop
	!=
	bz *if13_end

	// *if13_consequent
	// contracts/validatorRegistry.algo.ts:609
	// return this.validatorList(validatorId).value.tokenPayoutRatio
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	b *setTokenPayoutRatio*return

*if13_end:
	// contracts/validatorRegistry.algo.ts:615
	// curRound = globals.round
	global Round
	frame_bury 1 // curRound: uint64

	// contracts/validatorRegistry.algo.ts:616
	// lastPayoutUpdate = this.validatorList(validatorId).value.tokenPayoutRatio.updatedForPayout
	intc 31 // 892
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // lastPayoutUpdate: uint64

	// *if14_condition
	// contracts/validatorRegistry.algo.ts:617
	// lastPayoutUpdate !== 0
	frame_dig 2 // lastPayoutUpdate: uint64
	intc 0 // 0
	!=
	bz *if14_end

	// *if14_consequent
	// *if15_condition
	// contracts/validatorRegistry.algo.ts:619
	// (AppID.fromUint64(pool1AppID).globalState('lastPayout') as uint64) === lastPayoutUpdate
	frame_dig 0 // pool1AppID: uint64
	pushbytes 0x6c6173745061796f7574 // "lastPayout"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(pool1AppID).globalState('lastPayout')
	assert
	frame_dig 2 // lastPayoutUpdate: uint64
	==
	bz *if15_end

	// *if15_consequent
	// contracts/validatorRegistry.algo.ts:620
	// return this.validatorList(validatorId).value.tokenPayoutRatio
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	b *setTokenPayoutRatio*return

*if15_end:
	// contracts/validatorRegistry.algo.ts:622
	// epochRoundLength = this.validatorList(validatorId).value.config.epochRoundLength as uint64
	pushint 169
	intc 15 // 4
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 3 // epochRoundLength: uint64

	// contracts/validatorRegistry.algo.ts:623
	// thisEpochBegin = curRound - (curRound % epochRoundLength)
	frame_dig 1 // curRound: uint64
	frame_dig 1 // curRound: uint64
	frame_dig 3 // epochRoundLength: uint64
	%
	-
	frame_bury 4 // thisEpochBegin: uint64

	// *if16_condition
	// contracts/validatorRegistry.algo.ts:625
	// lastPayoutUpdate - (lastPayoutUpdate % epochRoundLength) === thisEpochBegin
	frame_dig 2 // lastPayoutUpdate: uint64
	frame_dig 2 // lastPayoutUpdate: uint64
	frame_dig 3 // epochRoundLength: uint64
	%
	-
	frame_dig 4 // thisEpochBegin: uint64
	==
	bz *if16_end

	// *if16_consequent
	// contracts/validatorRegistry.algo.ts:626
	// return this.validatorList(validatorId).value.tokenPayoutRatio
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	b *setTokenPayoutRatio*return

*if16_end:

*if14_end:
	// contracts/validatorRegistry.algo.ts:629
	// this.validatorList(validatorId).value.tokenPayoutRatio.updatedForPayout = curRound
	intc 31 // 892
	frame_dig 1 // curRound: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:631
	// curNumPools = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 5 // curNumPools: uint64

	// contracts/validatorRegistry.algo.ts:632
	// totalStakeForValidator = this.validatorList(validatorId).value.state.totalAlgoStaked
	intc 12 // 252
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 6 // totalStakeForValidator: uint64

	// contracts/validatorRegistry.algo.ts:633
	// for (let i = 0; i < curNumPools; i += 1)
	intc 0 // 0
	frame_bury 7 // i: uint64

*for_2:
	// contracts/validatorRegistry.algo.ts:633
	// i < curNumPools
	frame_dig 7 // i: uint64
	frame_dig 5 // curNumPools: uint64
	<
	bz *for_2_end

	// contracts/validatorRegistry.algo.ts:638
	// ourPoolPctOfWhole = wideRatio(
	//                 [this.validatorList(validatorId).value.pools[i].totalAlgoStaked, 1_000_000],
	//                 [totalStakeForValidator],
	//             )
	intc 5 //  headOffset
	frame_dig 7 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	pushint 1_000_000
	mulw
	intc 0 // 0
	frame_dig 6 // totalStakeForValidator: uint64
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 8 // ourPoolPctOfWhole: uint64

	// contracts/validatorRegistry.algo.ts:642
	// this.validatorList(validatorId).value.tokenPayoutRatio.poolPctOfWhole[i] = ourPoolPctOfWhole
	intc 14 // 700
	frame_dig 7 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	frame_dig 8 // ourPoolPctOfWhole: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

*for_2_continue:
	// contracts/validatorRegistry.algo.ts:633
	// i += 1
	frame_dig 7 // i: uint64
	intc 1 // 1
	+
	frame_bury 7 // i: uint64
	b *for_2

*for_2_end:
	// contracts/validatorRegistry.algo.ts:644
	// return this.validatorList(validatorId).value.tokenPayoutRatio
	intc 14 //  headOffset
	intc 19 // 200
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract

*setTokenPayoutRatio*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 8
	retsub

// stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void
*abi_route_stakeUpdatedViaRewards:
	// saturatedBurnToFeeSink: uint64
	txna ApplicationArgs 5
	btoi

	// validatorCommission: uint64
	txna ApplicationArgs 4
	btoi

	// rewardTokenAmountReserved: uint64
	txna ApplicationArgs 3
	btoi

	// algoToAdd: uint64
	txna ApplicationArgs 2
	btoi

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 24
	==

	// argument 4 (poolKey) for stakeUpdatedViaRewards must be a (uint64,uint64,uint64)
	assert

	// execute stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void
	callsub stakeUpdatedViaRewards
	intc 1 // 1
	return

// stakeUpdatedViaRewards(poolKey: ValidatorPoolKey, algoToAdd: uint64, rewardTokenAmountReserved: uint64, validatorCommission: uint64, saturatedBurnToFeeSink: uint64): void
//
// stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
// stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// The calling App id is validated against our pool list as well.
// @param {ValidatorPoolKey} poolKey - ValidatorPoolKey type
// @param {uint64} algoToAdd - amount this validator's total stake increased via rewards
// @param {uint64} rewardTokenAmountReserved - amount this validator's total stake increased via rewards (that should be
// @param {uint64} validatorCommission - the commission amount the validator was paid, if any
// @param {uint64} saturatedBurnToFeeSink - if the pool was in saturated state, the amount sent back to the fee sink.
// seen as 'accounted for/pending spent')
stakeUpdatedViaRewards:
	proto 5 0

	// contracts/validatorRegistry.algo.ts:665
	// this.verifyPoolKeyCaller(poolKey)
	frame_dig -1 // poolKey: ValidatorPoolKey
	callsub verifyPoolKeyCaller

	// contracts/validatorRegistry.algo.ts:668
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalAlgoStaked += algoToAdd
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // algoToAdd: uint64
	+
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:669
	// this.validatorList(poolKey.id).value.state.totalAlgoStaked += algoToAdd
	intc 12 // 252
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // algoToAdd: uint64
	+
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:670
	// this.validatorList(poolKey.id).value.state.rewardTokenHeldBack += rewardTokenAmountReserved
	intc 13 // 260
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // rewardTokenAmountReserved: uint64
	+
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:672
	// this.totalAlgoStaked.value += algoToAdd
	bytec 4 //  "staked"
	app_global_get
	frame_dig -2 // algoToAdd: uint64
	+
	bytec 4 //  "staked"
	swap
	app_global_put

	// contracts/validatorRegistry.algo.ts:675
	// this.reverifyNFDOwnership(poolKey.id)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	callsub reverifyNFDOwnership

	// contracts/validatorRegistry.algo.ts:677
	// this.retiOP_epochRewardUpdate.log({
	//             id: poolKey.id,
	//             poolNum: poolKey.poolId as uint16,
	//             poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//             algoAdded: algoToAdd,
	//             rewardTokenHeldBack: rewardTokenAmountReserved,
	//             saturatedBurnToFeeSink: saturatedBurnToFeeSink,
	//             validatorCommission: validatorCommission,
	//         })
	pushbytes 0xb3e47c3d // retiOP_epochRewardUpdate(uint64,uint16,uint64,uint64,uint64,uint64,uint64)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -4 // validatorCommission: uint64
	itob
	concat
	frame_dig -5 // saturatedBurnToFeeSink: uint64
	itob
	concat
	frame_dig -2 // algoToAdd: uint64
	itob
	concat
	frame_dig -3 // rewardTokenAmountReserved: uint64
	itob
	concat
	concat
	log
	retsub

// stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void
*abi_route_stakeRemoved:
	// stakerRemoved: bool
	txna ApplicationArgs 5
	dup
	len
	intc 1 // 1
	==

	// argument 0 (stakerRemoved) for stakeRemoved must be a bool
	assert
	intc 0 // 0
	getbit

	// rewardRemoved: uint64
	txna ApplicationArgs 4
	btoi

	// amountRemoved: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 3 (staker) for stakeRemoved must be a address
	assert

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 24
	==

	// argument 4 (poolKey) for stakeRemoved must be a (uint64,uint64,uint64)
	assert

	// execute stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void
	callsub stakeRemoved
	intc 1 // 1
	return

// stakeRemoved(poolKey: ValidatorPoolKey, staker: Address, amountRemoved: uint64, rewardRemoved: uint64, stakerRemoved: boolean): void
//
// stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
// from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
// The calling App id is validated against our pool list as well.
//
// @param {ValidatorPoolKey} poolKey calling us from which stake was removed
// @param {Address} staker
// @param {uint64} amountRemoved - algo amount removed
// @param {uint64} rewardRemoved - if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)
// @param {boolean} stakerRemoved
stakeRemoved:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 3

	// *if17_condition
	// contracts/validatorRegistry.algo.ts:707
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 29 // 300
	<
	bz *if17_end

	// *if17_consequent
	// contracts/validatorRegistry.algo.ts:708
	// increaseOpcodeBudget()
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 8 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 26 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if17_end:
	// contracts/validatorRegistry.algo.ts:710
	// this.verifyPoolKeyCaller(poolKey)
	frame_dig -1 // poolKey: ValidatorPoolKey
	callsub verifyPoolKeyCaller

	// contracts/validatorRegistry.algo.ts:714
	// assert(amountRemoved > 0 || rewardRemoved > 0, 'should only be called if algo or reward was removed')
	frame_dig -3 // amountRemoved: uint64
	intc 0 // 0
	>
	dup
	bnz *skip_or2
	frame_dig -4 // rewardRemoved: uint64
	intc 0 // 0
	>
	||

*skip_or2:
	// should only be called if algo or reward was removed
	assert

	// contracts/validatorRegistry.algo.ts:717
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalAlgoStaked -= amountRemoved
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:718
	// this.validatorList(poolKey.id).value.state.totalAlgoStaked -= amountRemoved
	intc 12 // 252
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:719
	// this.totalAlgoStaked.value -= amountRemoved
	bytec 4 //  "staked"
	app_global_get
	frame_dig -3 // amountRemoved: uint64
	-
	bytec 4 //  "staked"
	swap
	app_global_put

	// *if18_condition
	// contracts/validatorRegistry.algo.ts:721
	// rewardRemoved > 0
	frame_dig -4 // rewardRemoved: uint64
	intc 0 // 0
	>
	bz *if18_else

	// *if18_consequent
	// contracts/validatorRegistry.algo.ts:722
	// rewardTokenID = this.validatorList(poolKey.id).value.config.rewardTokenId
	intc 38 // 153
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // rewardTokenID: uint64

	// contracts/validatorRegistry.algo.ts:723
	// assert(rewardTokenID !== 0, "rewardRemoved can't be set if validator doesn't have reward token!")
	frame_dig 0 // rewardTokenID: uint64
	intc 0 // 0
	!=

	// rewardRemoved can't be set if validator doesn't have reward token!
	assert

	// contracts/validatorRegistry.algo.ts:724
	// assert(
	//                 this.validatorList(poolKey.id).value.state.rewardTokenHeldBack >= rewardRemoved,
	//                 'reward being removed must be covered by hold back amount',
	//             )
	intc 13 // 260
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -4 // rewardRemoved: uint64
	>=

	// reward being removed must be covered by hold back amount
	assert

	// contracts/validatorRegistry.algo.ts:730
	// this.validatorList(poolKey.id).value.state.rewardTokenHeldBack -= rewardRemoved
	intc 13 // 260
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -4 // rewardRemoved: uint64
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// *if19_condition
	// contracts/validatorRegistry.algo.ts:735
	// poolKey.poolId !== 1
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	!=
	bz *if19_end

	// *if19_consequent
	// contracts/validatorRegistry.algo.ts:736
	// sendMethodCall<typeof StakingPool.prototype.payTokenReward>({
	//                     applicationID: AppID.fromUint64(this.validatorList(poolKey.id).value.pools[0].poolAppId),
	//                     methodArgs: [staker, rewardTokenID, rewardRemoved],
	//                 })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	bytec 13 //  method "payTokenReward(address,uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:737
	// applicationID: AppID.fromUint64(this.validatorList(poolKey.id).value.pools[0].poolAppId)
	intc 5 // 268
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:738
	// methodArgs: [staker, rewardTokenID, rewardRemoved]
	frame_dig -2 // staker: Address
	itxn_field ApplicationArgs
	frame_dig 0 // rewardTokenID: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -4 // rewardRemoved: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if19_end:
	// contracts/validatorRegistry.algo.ts:741
	// this.retiOP_stakeRemoved.log({
	//                 id: poolKey.id,
	//                 poolNum: poolKey.poolId as uint16,
	//                 poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//                 staker: staker,
	//                 amountUnstaked: amountRemoved,
	//                 rewardTokenAssetId: AssetID.fromUint64(rewardTokenID),
	//                 rewardTokensReceived: rewardRemoved,
	//             })
	bytec 14 //  retiOP_stakeRemoved(uint64,uint16,uint64,address,uint64,uint64,uint64)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	concat
	frame_dig -3 // amountRemoved: uint64
	itob
	concat
	frame_dig -4 // rewardRemoved: uint64
	itob
	concat
	frame_dig 0 // rewardTokenID: uint64
	itob
	concat
	concat
	log
	b *if18_end

*if18_else:
	// contracts/validatorRegistry.algo.ts:751
	// this.retiOP_stakeRemoved.log({
	//                 id: poolKey.id,
	//                 poolNum: poolKey.poolId as uint16,
	//                 poolAppId: AppID.fromUint64(poolKey.poolAppId),
	//                 staker: staker,
	//                 amountUnstaked: amountRemoved,
	//                 // no tokens rewarded..
	//                 rewardTokenAssetId: AssetID.zeroIndex,
	//                 rewardTokensReceived: 0,
	//             })
	bytec 14 //  retiOP_stakeRemoved(uint64,uint16,uint64,address,uint64,uint64,uint64)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	dup
	bitlen
	intc 18 // 16
	<=

	// poolKey.poolId as uint16 overflowed 16 bits
	assert
	extract 6 2
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	concat
	frame_dig -3 // amountRemoved: uint64
	itob
	concat
	bytec 7 // 0x0000000000000000
	concat
	bytec 7 // 0x0000000000000000
	concat
	concat
	log

*if18_end:
	// *if20_condition
	// contracts/validatorRegistry.algo.ts:763
	// stakerRemoved
	frame_dig -5 // stakerRemoved: boolean
	bz *if20_end

	// *if20_consequent
	// contracts/validatorRegistry.algo.ts:765
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalStakers -= 1
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 2 //  headOffset
	+
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 2 //  headOffset
	+
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	extract 6 2
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:767
	// removeRet = this.removeFromStakerPoolSet(staker, <ValidatorPoolKey>{
	//                 id: poolKey.id,
	//                 poolId: poolKey.poolId,
	//                 poolAppId: poolKey.poolAppId,
	//             })
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	callsub removeFromStakerPoolSet
	frame_bury 1 // removeRet: (bool,bool)

	// contracts/validatorRegistry.algo.ts:772
	// stakerOutOfThisValidator = removeRet[0]
	frame_dig 1 // removeRet: (bool,bool)
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	frame_bury 2 // stakerOutOfThisValidator: bool

	// contracts/validatorRegistry.algo.ts:773
	// stakerOutOfProtocol = removeRet[1]
	frame_dig 1 // removeRet: (bool,bool)
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	getbit
	frame_bury 3 // stakerOutOfProtocol: bool

	// *if21_condition
	// contracts/validatorRegistry.algo.ts:775
	// stakerOutOfThisValidator
	frame_dig 2 // stakerOutOfThisValidator: bool
	bz *if21_end

	// *if21_consequent
	// contracts/validatorRegistry.algo.ts:776
	// this.validatorList(poolKey.id).value.state.totalStakers -= 1
	intc 23 // 244
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

*if21_end:
	// *if22_condition
	// contracts/validatorRegistry.algo.ts:779
	// stakerOutOfProtocol
	frame_dig 3 // stakerOutOfProtocol: bool
	bz *if22_end

	// *if22_consequent
	// contracts/validatorRegistry.algo.ts:780
	// this.numStakers.value -= 1
	bytec 6 //  "numStakers"
	app_global_get
	intc 1 // 1
	-
	bytec 6 //  "numStakers"
	swap
	app_global_put

*if22_end:

*if20_end:
	retsub

// findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)
*abi_route_findPoolForStaker:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// amountToStake: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 1 (staker) for findPoolForStaker must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)
	callsub findPoolForStaker
	concat
	log
	intc 1 // 1
	return

// findPoolForStaker(validatorId: ValidatorIdType, staker: Address, amountToStake: uint64): [ValidatorPoolKey, boolean, boolean]
//
// Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
// First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
// to new pool if necessary.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {Address} staker - The address of the staker.
// @param {uint64} amountToStake - The amount to stake.
// @returns {ValidatorPoolKey, boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
// to this VALIDATOR, and true/false if staker is new to the protocol.
findPoolForStaker:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 7

	// contracts/validatorRegistry.algo.ts:802
	// isNewStakerToValidator = true
	intc 1 // 1
	frame_bury 0 // isNewStakerToValidator: bool

	// contracts/validatorRegistry.algo.ts:803
	// isNewStakerToProtocol = true
	intc 1 // 1
	frame_bury 1 // isNewStakerToProtocol: bool

	// contracts/validatorRegistry.algo.ts:811
	// maxPerPool = this.getCurMaxStakePerPool(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub getCurMaxStakePerPool
	frame_bury 2 // maxPerPool: uint64

	// *if23_condition
	// contracts/validatorRegistry.algo.ts:814
	// this.stakerPoolSet(staker).exists
	bytec 3 //  "sps"
	frame_dig -2 // staker: Address
	concat
	box_len
	swap
	pop
	bz *if23_end

	// *if23_consequent
	// contracts/validatorRegistry.algo.ts:815
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -2 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 3 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:816
	// assert(validatorId !== 0)
	frame_dig -1 // validatorId: ValidatorIdType
	intc 0 // 0
	!=
	assert

	// contracts/validatorRegistry.algo.ts:817
	// for (let i = 0; i < poolSet.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_3:
	// contracts/validatorRegistry.algo.ts:817
	// i < poolSet.length
	frame_dig 4 // i: uint64
	intc 7 // 6
	<
	bz *for_3_end

	// *if24_condition
	// contracts/validatorRegistry.algo.ts:818
	// globals.opcodeBudget < 300
	global OpcodeBudget
	intc 29 // 300
	<
	bz *if24_end

	// *if24_consequent
	// contracts/validatorRegistry.algo.ts:819
	// increaseOpcodeBudget()
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 8 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 26 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if24_end:
	// *if25_condition
	// contracts/validatorRegistry.algo.ts:821
	// poolSet[i].id === 0
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if25_end

	// *if25_consequent
	b *for_3_continue

*if25_end:
	// contracts/validatorRegistry.algo.ts:824
	// isNewStakerToProtocol = false
	intc 0 // 0
	frame_bury 1 // isNewStakerToProtocol: bool

	// *if26_condition
	// contracts/validatorRegistry.algo.ts:825
	// poolSet[i].id === validatorId
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -1 // validatorId: ValidatorIdType
	==
	bz *if26_end

	// *if26_consequent
	// contracts/validatorRegistry.algo.ts:827
	// isNewStakerToValidator = false
	intc 0 // 0
	frame_bury 0 // isNewStakerToValidator: bool

	// *if27_condition
	// contracts/validatorRegistry.algo.ts:829
	// this.validatorList(validatorId).value.pools[poolSet[i].poolId - 1].totalAlgoStaked +
	//                             amountToStake <=
	//                         maxPerPool
	intc 5 //  headOffset
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 2 //  headOffset
	+
	intc 2 // 8
	extract3
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 2 // maxPerPool: uint64
	<=
	bz *if27_end

	// *if27_consequent
	// contracts/validatorRegistry.algo.ts:833
	// return [poolSet[i], isNewStakerToValidator, isNewStakerToProtocol]
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	intc 1 // 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat
	b *findPoolForStaker*return

*if27_end:

*if26_end:

*for_3_continue:
	// contracts/validatorRegistry.algo.ts:817
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_3

*for_3_end:

*if23_end:
	// contracts/validatorRegistry.algo.ts:840
	// assert(
	//             amountToStake >= this.validatorList(validatorId).value.config.minEntryStake,
	//             'must stake at least the minimum for this pool',
	//         )
	frame_dig -3 // amountToStake: uint64
	intc 39 // 209
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	>=

	// must stake at least the minimum for this pool
	assert

	// contracts/validatorRegistry.algo.ts:846
	// pools = clone(this.validatorList(validatorId).value.pools)
	intc 5 //  headOffset
	intc 30 // 432
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 5 // pools: (uint64,uint16,uint64)[24]

	// contracts/validatorRegistry.algo.ts:847
	// curNumPools = this.validatorList(validatorId).value.state.numPools as uint64
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 6 // curNumPools: uint64

	// contracts/validatorRegistry.algo.ts:848
	// for (let i = 0; i < curNumPools; i += 1)
	intc 0 // 0
	frame_bury 7 // i: uint64

*for_4:
	// contracts/validatorRegistry.algo.ts:848
	// i < curNumPools
	frame_dig 7 // i: uint64
	frame_dig 6 // curNumPools: uint64
	<
	bz *for_4_end

	// *if28_condition
	// contracts/validatorRegistry.algo.ts:849
	// pools[i].totalAlgoStaked + amountToStake <= maxPerPool
	frame_dig 5 // pools: (uint64,uint16,uint64)[24]
	frame_dig 7 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 11 //  headOffset
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 2 // maxPerPool: uint64
	<=
	bz *if28_end

	// *if28_consequent
	// contracts/validatorRegistry.algo.ts:850
	// return [
	//                     { id: validatorId, poolId: i + 1, poolAppId: pools[i].poolAppId },
	//                     isNewStakerToValidator,
	//                     isNewStakerToProtocol,
	//                 ]
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	frame_dig 7 // i: uint64
	intc 1 // 1
	+
	itob
	concat
	frame_dig 5 // pools: (uint64,uint16,uint64)[24]
	frame_dig 7 // i: uint64
	intc 4 // 18
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	itob
	concat
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	intc 1 // 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat
	b *findPoolForStaker*return

*if28_end:

*for_4_continue:
	// contracts/validatorRegistry.algo.ts:848
	// i += 1
	frame_dig 7 // i: uint64
	intc 1 // 1
	+
	frame_bury 7 // i: uint64
	b *for_4

*for_4_end:
	// contracts/validatorRegistry.algo.ts:858
	// return [{ id: validatorId, poolId: 0, poolAppId: 0 }, isNewStakerToValidator, isNewStakerToProtocol]
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	bytec 7 // 0x0000000000000000
	concat
	bytec 7 // 0x0000000000000000
	concat
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	intc 1 // 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat

*findPoolForStaker*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// movePoolToNode(uint64,uint64,uint64)void
*abi_route_movePoolToNode:
	// nodeNum: uint64
	txna ApplicationArgs 3
	btoi

	// poolAppId: uint64
	txna ApplicationArgs 2
	btoi

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute movePoolToNode(uint64,uint64,uint64)void
	callsub movePoolToNode
	intc 1 // 1
	return

// movePoolToNode(validatorId: ValidatorIdType, poolAppId: uint64, nodeNum: uint64): void
//
// Find the specified pool (in any node number) and move it to the specified node.
// The pool account is forced offline if moved so prior node will still run for 320 rounds but
// new key goes online on new node soon after (320 rounds after it goes online)
// No-op if success, asserts if not found or can't move  (no space in target)
// [ ONLY OWNER OR MANAGER CAN CHANGE ]
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {uint64} poolAppId
// @param {uint64} nodeNum
movePoolToNode:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:873
	// this.callerMustBeOwnerOrManager(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwnerOrManager

	// contracts/validatorRegistry.algo.ts:875
	// nodePoolAssignments = clone(this.validatorList(validatorId).value.nodePoolAssignments)
	intc 17 //  headOffset
	intc 22 // 192
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // nodePoolAssignments: ((uint64[3])[8])

	// contracts/validatorRegistry.algo.ts:876
	// assert(nodeNum >= 1 && nodeNum <= MAX_NODES, 'node number out of allowable range')
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	>=
	dup
	bz *skip_and2
	frame_dig -3 // nodeNum: uint64
	intc 2 // 8
	<=
	&&

*skip_and2:
	// node number out of allowable range
	assert

	// contracts/validatorRegistry.algo.ts:878
	// for (let srcNodeIdx = 0; srcNodeIdx < MAX_NODES; srcNodeIdx += 1)
	intc 0 // 0
	frame_bury 1 // srcNodeIdx: uint64

*for_5:
	// contracts/validatorRegistry.algo.ts:878
	// srcNodeIdx < MAX_NODES
	frame_dig 1 // srcNodeIdx: uint64
	intc 2 // 8
	<
	bz *for_5_end

	// contracts/validatorRegistry.algo.ts:879
	// for (let i = 0; i < MAX_POOLS_PER_NODE; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_6:
	// contracts/validatorRegistry.algo.ts:879
	// i < MAX_POOLS_PER_NODE
	frame_dig 2 // i: uint64
	intc 8 // 3
	<
	bz *for_6_end

	// *if29_condition
	// contracts/validatorRegistry.algo.ts:880
	// nodePoolAssignments.nodes[srcNodeIdx].poolAppIds[i] === poolAppId
	frame_dig 0 // nodePoolAssignments: ((uint64[3])[8])
	intc 0 // 0
	frame_dig 1 // srcNodeIdx: uint64
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -2 // poolAppId: uint64
	==
	bz *if29_end

	// *if29_consequent
	// contracts/validatorRegistry.algo.ts:881
	// assert(nodeNum - 1 !== srcNodeIdx, "can't move to same node")
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	-
	frame_dig 1 // srcNodeIdx: uint64
	!=

	// can't move to same node
	assert

	// contracts/validatorRegistry.algo.ts:883
	// this.validatorList(validatorId).value.nodePoolAssignments.nodes[srcNodeIdx].poolAppIds[i] = 0
	intc 17 // 900
	frame_dig 1 // srcNodeIdx: uint64
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	bytec 7 // 0x0000000000000000
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:886
	// sendMethodCall<typeof StakingPool.prototype.goOffline>({
	//                         applicationID: AppID.fromUint64(poolAppId),
	//                     })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	pushbytes 0x51ef3b21 // method "goOffline()void"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:887
	// applicationID: AppID.fromUint64(poolAppId)
	frame_dig -2 // poolAppId: uint64
	itxn_field ApplicationID

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:891
	// this.addPoolToNode(validatorId, poolAppId, nodeNum)
	frame_dig -3 // nodeNum: uint64
	frame_dig -2 // poolAppId: uint64
	frame_dig -1 // validatorId: ValidatorIdType
	callsub addPoolToNode

	// contracts/validatorRegistry.algo.ts:892
	// return
	retsub

*if29_end:

*for_6_continue:
	// contracts/validatorRegistry.algo.ts:879
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_6

*for_6_end:

*for_5_continue:
	// contracts/validatorRegistry.algo.ts:878
	// srcNodeIdx += 1
	frame_dig 1 // srcNodeIdx: uint64
	intc 1 // 1
	+
	frame_bury 1 // srcNodeIdx: uint64
	b *for_5

*for_5_end:
	// couldn't find pool app id in nodes to move
	err
	retsub

// emptyTokenRewards(uint64,address)uint64
*abi_route_emptyTokenRewards:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	intc 6 // 32
	==

	// argument 0 (receiver) for emptyTokenRewards must be a address
	assert

	// validatorId: uint64
	txna ApplicationArgs 1
	btoi

	// execute emptyTokenRewards(uint64,address)uint64
	callsub emptyTokenRewards
	itob
	concat
	log
	intc 1 // 1
	return

// emptyTokenRewards(validatorId: ValidatorIdType, receiver: Address): uint64
//
// Sends the reward tokens held in pool 1 to specified receiver.
// This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
// the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
// NOT be sent as they must be held back for stakers to later claim.
// [ ONLY OWNER CAN CALL]
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {Address} receiver - the account to send the tokens to (must already be opted-in to the reward token)
// @returns {uint64} the amount of reward token sent
emptyTokenRewards:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 3

	// contracts/validatorRegistry.algo.ts:911
	// this.callerMustBeOwner(validatorId)
	frame_dig -1 // validatorId: ValidatorIdType
	callsub callerMustBeOwner

	// contracts/validatorRegistry.algo.ts:912
	// rewardTokenId = this.validatorList(validatorId).value.config.rewardTokenId
	intc 38 // 153
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // rewardTokenId: uint64

	// contracts/validatorRegistry.algo.ts:913
	// rewardTokenHeldBack = this.validatorList(validatorId).value.state.rewardTokenHeldBack
	intc 13 // 260
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // rewardTokenHeldBack: uint64

	// contracts/validatorRegistry.algo.ts:914
	// assert(rewardTokenId !== 0, "this validator doesn't have a reward token defined")
	frame_dig 0 // rewardTokenId: uint64
	intc 0 // 0
	!=

	// this validator doesn't have a reward token defined
	assert

	// contracts/validatorRegistry.algo.ts:915
	// poolOneAppId = AppID.fromUint64(this.validatorList(validatorId).value.pools[0].poolAppId)
	intc 5 // 268
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // poolOneAppId: uint64

	// contracts/validatorRegistry.algo.ts:917
	// tokenRewardBal =
	//             poolOneAppId.address.assetBalance(AssetID.fromUint64(rewardTokenId)) - rewardTokenHeldBack
	frame_dig 2 // poolOneAppId: uint64
	app_params_get AppAddress
	pop
	frame_dig 0 // rewardTokenId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 1 // rewardTokenHeldBack: uint64
	-
	frame_bury 3 // tokenRewardBal: uint64

	// contracts/validatorRegistry.algo.ts:921
	// sendMethodCall<typeof StakingPool.prototype.payTokenReward>({
	//             applicationID: poolOneAppId,
	//             methodArgs: [receiver, rewardTokenId, tokenRewardBal],
	//         })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	bytec 13 //  method "payTokenReward(address,uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:922
	// applicationID: poolOneAppId
	frame_dig 2 // poolOneAppId: uint64
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:923
	// methodArgs: [receiver, rewardTokenId, tokenRewardBal]
	frame_dig -2 // receiver: Address
	itxn_field ApplicationArgs
	frame_dig 0 // rewardTokenId: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig 3 // tokenRewardBal: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:925
	// assert(
	//             poolOneAppId.address.assetBalance(AssetID.fromUint64(rewardTokenId)) === rewardTokenHeldBack,
	//             'balance of remaining reward tokens should match the held back amount',
	//         )
	frame_dig 2 // poolOneAppId: uint64
	app_params_get AppAddress
	pop
	frame_dig 0 // rewardTokenId: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 1 // rewardTokenHeldBack: uint64
	==

	// balance of remaining reward tokens should match the held back amount
	assert

	// contracts/validatorRegistry.algo.ts:929
	// return tokenRewardBal
	frame_dig 3 // tokenRewardBal: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// callerMustBeOwner(validatorId: ValidatorIdType): void
callerMustBeOwner:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:1022
	// assert(
	//             this.txn.sender === this.validatorList(validatorId).value.config.owner,
	//             'can only be called by validator owner',
	//         )
	txn Sender
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	==

	// can only be called by validator owner
	assert
	retsub

// callerMustBeOwnerOrManager(validatorId: ValidatorIdType): void
callerMustBeOwnerOrManager:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:1029
	// assert(
	//             this.txn.sender === this.validatorList(validatorId).value.config.owner ||
	//                 this.txn.sender === this.validatorList(validatorId).value.config.manager,
	//             'can only be called by owner or manager of validator',
	//         )
	txn Sender
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	==
	dup
	bnz *skip_or3
	txn Sender
	intc 20 // 40
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	==
	||

*skip_or3:
	// can only be called by owner or manager of validator
	assert
	retsub

// verifyPoolKeyCaller(poolKey: ValidatorPoolKey): void
//
// verifyPoolKeyCaller verifies the passed in key (from a staking pool calling us to update metrics) is valid
// and matches the information we have in our state.  'Fake' pools could call us to update our data, but they
// can't fake the ids and most importantly application id(!) of the caller that has to match.
verifyPoolKeyCaller:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:1042
	// assert(this.validatorList(poolKey.id).exists, "the specified validator id isn't valid")
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	box_len
	swap
	pop

	// the specified validator id isn't valid
	assert

	// contracts/validatorRegistry.algo.ts:1043
	// assert(poolKey.poolId <= MAX_POOLS, 'pool id not in valid range')
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 3 // 24
	<=

	// pool id not in valid range
	assert

	// contracts/validatorRegistry.algo.ts:1044
	// assert(
	//             poolKey.poolId > 0 && (poolKey.poolId as uint16) <= this.validatorList(poolKey.id).value.state.numPools,
	//             'pool id outside of range of pools created for this validator',
	//         )
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 0 // 0
	>
	dup
	bz *skip_and3
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 9 // 242
	intc 10 // 2
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	<=
	&&

*skip_and3:
	// pool id outside of range of pools created for this validator
	assert

	// contracts/validatorRegistry.algo.ts:1050
	// assert(
	//             poolKey.poolAppId === this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].poolAppId,
	//             "The passed in app id doesn't match the passed in ids",
	//         )
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	intc 5 //  headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	==

	// The passed in app id doesn't match the passed in ids
	assert

	// contracts/validatorRegistry.algo.ts:1055
	// assert(this.txn.sender === AppID.fromUint64(poolKey.poolAppId).address)
	txn Sender
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	app_params_get AppAddress
	pop
	==
	assert

	// contracts/validatorRegistry.algo.ts:1057
	// assert(poolKey.id === (AppID.fromUint64(poolKey.poolAppId).globalState('validatorId') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	pushbytes 0x76616c696461746f724964 // "validatorId"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolKey.poolAppId).globalState('validatorId')
	assert
	==
	assert

	// contracts/validatorRegistry.algo.ts:1058
	// assert(poolKey.poolId === (AppID.fromUint64(poolKey.poolAppId).globalState('poolId') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	pushbytes 0x706f6f6c4964 // "poolId"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolKey.poolAppId).globalState('poolId')
	assert
	==
	assert
	retsub

// reverifyNFDOwnership(validatorId: ValidatorIdType): void
//
// This method verifies the ownership of NFD (Named Function Data) by a validator.
// If the ownership is no longer valid, it removes the NFD from the validator's configuration.
//
// @param {ValidatorIdType} validatorId - The id of the validator whose data should be re-evaluated.
reverifyNFDOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/validatorRegistry.algo.ts:1068
	// validatorConfig = this.validatorList(validatorId).value.config
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	frame_bury 0 // storage key//validatorConfig

	// *if30_condition
	// contracts/validatorRegistry.algo.ts:1069
	// validatorConfig.nfdForInfo !== 0
	intc 21 // 72
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	!=
	bz *if30_end

	// *if30_consequent
	// contracts/validatorRegistry.algo.ts:1072
	// nfdOwner = AppID.fromUint64(validatorConfig.nfdForInfo).globalState('i.owner.a') as Address
	intc 21 // 72
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(validatorConfig.nfdForInfo).globalState('i.owner.a')
	assert
	frame_bury 1 // nfdOwner: address

	// *if31_condition
	// contracts/validatorRegistry.algo.ts:1074
	// validatorConfig.owner !== nfdOwner && validatorConfig.manager !== nfdOwner
	intc 2 // 8
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_dig 1 // nfdOwner: address
	!=
	dup
	bz *skip_and4
	intc 20 // 40
	intc 6 // 32
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_dig 1 // nfdOwner: address
	!=
	&&

*skip_and4:
	bz *if31_end

	// *if31_consequent
	// contracts/validatorRegistry.algo.ts:1076
	// this.validatorList(validatorId).value.config.nfdForInfo = 0
	intc 21 // 72
	bytec 7 // 0x0000000000000000
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

*if31_end:

*if30_end:
	retsub

// validateConfig(config: ValidatorConfig): void
validateConfig:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:1083
	// assert(config.owner !== Address.zeroAddress)
	frame_dig -1 // config: ValidatorConfig
	extract 8 32
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:1084
	// assert(config.manager !== Address.zeroAddress)
	frame_dig -1 // config: ValidatorConfig
	extract 40 32
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:1085
	// assert(this.txn.sender === config.owner, 'sender must be owner to add new validator')
	txn Sender
	frame_dig -1 // config: ValidatorConfig
	extract 8 32
	==

	// sender must be owner to add new validator
	assert

	// contracts/validatorRegistry.algo.ts:1087
	// assert(
	//             config.entryGatingType >= GATING_TYPE_NONE && config.entryGatingType <= GATING_TYPE_CONST_MAX,
	//             'gating type not valid',
	//         )
	frame_dig -1 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 0 // 0
	>=
	dup
	bz *skip_and5
	frame_dig -1 // config: ValidatorConfig
	extract 80 1
	btoi
	intc 15 // 4
	<=
	&&

*skip_and5:
	// gating type not valid
	assert

	// contracts/validatorRegistry.algo.ts:1091
	// assert(
	//             config.epochRoundLength >= MIN_EPOCH_LENGTH && config.epochRoundLength <= MAX_EPOCH_LENGTH,
	//             'epoch length not in allowable range',
	//         )
	frame_dig -1 // config: ValidatorConfig
	extract 169 4
	btoi
	intc 1 // 1
	>=
	dup
	bz *skip_and6
	frame_dig -1 // config: ValidatorConfig
	extract 169 4
	btoi
	intc 24 // 1000000
	<=
	&&

*skip_and6:
	// epoch length not in allowable range
	assert

	// contracts/validatorRegistry.algo.ts:1095
	// assert(
	//             config.percentToValidator >= MIN_PCT_TO_VALIDATOR && config.percentToValidator <= MAX_PCT_TO_VALIDATOR,
	//             'commission percentage not valid',
	//         )
	frame_dig -1 // config: ValidatorConfig
	extract 173 4
	btoi
	intc 0 // 0
	>=
	dup
	bz *skip_and7
	frame_dig -1 // config: ValidatorConfig
	extract 173 4
	btoi
	intc 24 // 1000000
	<=
	&&

*skip_and7:
	// commission percentage not valid
	assert

	// *if32_condition
	// contracts/validatorRegistry.algo.ts:1099
	// config.percentToValidator !== 0
	frame_dig -1 // config: ValidatorConfig
	extract 173 4
	btoi
	intc 0 // 0
	!=
	bz *if32_end

	// *if32_consequent
	// contracts/validatorRegistry.algo.ts:1100
	// assert(
	//                 config.validatorCommissionAddress !== Address.zeroAddress,
	//                 'validatorCommissionAddress must be set if percent to validator is not 0',
	//             )
	frame_dig -1 // config: ValidatorConfig
	extract 177 32
	global ZeroAddress
	!=

	// validatorCommissionAddress must be set if percent to validator is not 0
	assert

*if32_end:
	// contracts/validatorRegistry.algo.ts:1105
	// assert(config.minEntryStake >= MIN_ALGO_STAKE_PER_POOL, 'staking pool must have minimum entry of 1 algo')
	frame_dig -1 // config: ValidatorConfig
	extract 209 8
	btoi
	intc 24 // 1000000
	>=

	// staking pool must have minimum entry of 1 algo
	assert

	// contracts/validatorRegistry.algo.ts:1107
	// assert(
	//             config.poolsPerNode > 0 && config.poolsPerNode <= MAX_POOLS_PER_NODE,
	//             'number of pools per node must be be between 1 and the maximum allowed number',
	//         )
	frame_dig -1 // config: ValidatorConfig
	extract 225 1
	btoi
	intc 0 // 0
	>
	dup
	bz *skip_and8
	frame_dig -1 // config: ValidatorConfig
	extract 225 1
	btoi
	intc 8 // 3
	<=
	&&

*skip_and8:
	// number of pools per node must be be between 1 and the maximum allowed number
	assert

	// *if33_condition
	// contracts/validatorRegistry.algo.ts:1111
	// config.sunsettingOn !== 0
	frame_dig -1 // config: ValidatorConfig
	extract 226 8
	btoi
	intc 0 // 0
	!=
	bz *if33_end

	// *if33_consequent
	// contracts/validatorRegistry.algo.ts:1112
	// assert(config.sunsettingOn > globals.latestTimestamp, 'sunsettingOn must be later than now if set')
	frame_dig -1 // config: ValidatorConfig
	extract 226 8
	btoi
	global LatestTimestamp
	>

	// sunsettingOn must be later than now if set
	assert

*if33_end:
	retsub

// callPoolAddStake(stakedAmountPayment: PayTxn, poolKey: ValidatorPoolKey, mbrAmtPaid: uint64, isNewStakerToValidator: boolean, isNewStakerToProtocol: boolean): void
//
// Adds a stakers amount of algo to a validator pool, transferring the algo we received from them (already verified
// by our caller) to the staking pool account, and then telling it about the amount being added for the specified
// staker.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorPoolKey} poolKey - The key of the validator pool.
// @param {uint64} mbrAmtPaid - Amount the user is leaving behind in the validator to pay for their staker MBR cost
// @param {boolean} isNewStakerToValidator - if this is a new, first-time staker to the validator
// @param {boolean} isNewStakerToProtocol - if this is a new, first-time staker to the protocol
callPoolAddStake:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:1134
	// poolAppId = this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].poolAppId
	intc 5 //  headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 0 // 0
	+
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // poolAppId: uint64

	// contracts/validatorRegistry.algo.ts:1138
	// sendMethodCall<typeof StakingPool.prototype.addStake, uint64>({
	//             applicationID: AppID.fromUint64(poolAppId),
	//             methodArgs: [
	//                 // =======
	//                 // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//                 { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: AppID.fromUint64(poolAppId).address },
	//                 // =======
	//                 stakedAmountPayment.sender,
	//             ],
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:1143
	// amount: stakedAmountPayment.amount - mbrAmtPaid
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	itxn_field Amount

	// contracts/validatorRegistry.algo.ts:1143
	// receiver: AppID.fromUint64(poolAppId).address
	frame_dig 0 // poolAppId: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 7 //  appl
	itxn_field TypeEnum
	pushbytes 0xf9c70cbd // method "addStake(pay,address)uint64"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:1139
	// applicationID: AppID.fromUint64(poolAppId)
	frame_dig 0 // poolAppId: uint64
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:1140
	// methodArgs: [
	//                 // =======
	//                 // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//                 { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: AppID.fromUint64(poolAppId).address },
	//                 // =======
	//                 stakedAmountPayment.sender,
	//             ]
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	btoi

	// *if34_condition
	// contracts/validatorRegistry.algo.ts:1148
	// globals.opcodeBudget < 500
	global OpcodeBudget
	pushint 500
	<
	bz *if34_end

	// *if34_consequent
	// contracts/validatorRegistry.algo.ts:1149
	// increaseOpcodeBudget()
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 8 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 26 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if34_end:
	// contracts/validatorRegistry.algo.ts:1153
	// poolNumStakers = AppID.fromUint64(poolAppId).globalState('numStakers') as uint64
	frame_dig 0 // poolAppId: uint64
	bytec 6 //  "numStakers"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolAppId).globalState('numStakers')
	assert
	frame_bury 1 // poolNumStakers: uint64

	// contracts/validatorRegistry.algo.ts:1154
	// poolAlgoStaked = AppID.fromUint64(poolAppId).globalState('staked') as uint64
	frame_dig 0 // poolAppId: uint64
	bytec 4 //  "staked"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(poolAppId).globalState('staked')
	assert
	frame_bury 2 // poolAlgoStaked: uint64

	// contracts/validatorRegistry.algo.ts:1155
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalStakers = poolNumStakers as uint16
	intc 5 //  headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 2 //  headOffset
	+
	frame_dig 1 // poolNumStakers: uint64
	itob
	extract 6 2
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:1156
	// this.validatorList(poolKey.id).value.pools[poolKey.poolId - 1].totalAlgoStaked = poolAlgoStaked
	intc 5 //  headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	intc 1 // 1
	-
	intc 4 // 18
	* // acc * typeLength
	+
	intc 11 //  headOffset
	+
	frame_dig 2 // poolAlgoStaked: uint64
	itob
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// *if35_condition
	// contracts/validatorRegistry.algo.ts:1159
	// isNewStakerToValidator
	frame_dig -4 // isNewStakerToValidator: boolean
	bz *if35_end

	// *if35_consequent
	// contracts/validatorRegistry.algo.ts:1160
	// this.validatorList(poolKey.id).value.state.totalStakers += 1
	intc 23 // 244
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

*if35_end:
	// *if36_condition
	// contracts/validatorRegistry.algo.ts:1162
	// isNewStakerToProtocol
	frame_dig -5 // isNewStakerToProtocol: boolean
	bz *if36_end

	// *if36_consequent
	// contracts/validatorRegistry.algo.ts:1163
	// this.numStakers.value += 1
	bytec 6 //  "numStakers"
	app_global_get
	intc 1 // 1
	+
	bytec 6 //  "numStakers"
	swap
	app_global_put

*if36_end:
	// contracts/validatorRegistry.algo.ts:1165
	// this.validatorList(poolKey.id).value.state.totalAlgoStaked += stakedAmountPayment.amount - mbrAmtPaid
	intc 12 // 252
	dup
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	+
	itob
	bytec 0 //  "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:1166
	// this.totalAlgoStaked.value += stakedAmountPayment.amount - mbrAmtPaid
	bytec 4 //  "staked"
	app_global_get
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	+
	bytec 4 //  "staked"
	swap
	app_global_put
	retsub

// updateStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): void
updateStakerPoolSet:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:1170
	// assert(this.stakerPoolSet(staker).exists)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:1172
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 0 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:1173
	// firstEmpty = 0
	intc 0 // 0
	frame_bury 1 // firstEmpty: uint64

	// contracts/validatorRegistry.algo.ts:1174
	// for (let i = 0; i < this.stakerPoolSet(staker).value.length; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_7:
	// contracts/validatorRegistry.algo.ts:1174
	// i < this.stakerPoolSet(staker).value.length
	frame_dig 2 // i: uint64
	intc 7 // 6
	<
	bz *for_7_end

	// *if37_condition
	// contracts/validatorRegistry.algo.ts:1175
	// poolSet[i] === poolKey
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz *if37_end

	// *if37_consequent
	// contracts/validatorRegistry.algo.ts:1177
	// return
	retsub

*if37_end:
	// *if38_condition
	// contracts/validatorRegistry.algo.ts:1179
	// firstEmpty === 0 && poolSet[i].id === 0
	frame_dig 1 // firstEmpty: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and9
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	&&

*skip_and9:
	bz *if38_end

	// *if38_consequent
	// contracts/validatorRegistry.algo.ts:1180
	// firstEmpty = i + 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // firstEmpty: uint64

*if38_end:

*for_7_continue:
	// contracts/validatorRegistry.algo.ts:1174
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_7

*for_7_end:
	// *if39_condition
	// contracts/validatorRegistry.algo.ts:1183
	// firstEmpty === 0
	frame_dig 1 // firstEmpty: uint64
	intc 0 // 0
	==
	bz *if39_end

	// *if39_consequent
	// No empty slot available in the staker pool set
	err

*if39_end:
	// contracts/validatorRegistry.algo.ts:1186
	// this.stakerPoolSet(staker).value[firstEmpty - 1] = poolKey
	frame_dig 1 // firstEmpty: uint64
	intc 1 // 1
	-
	intc 3 // 24
	* // acc * typeLength
	frame_dig -2 // poolKey: ValidatorPoolKey
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace
	retsub

// removeFromStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): [boolean, boolean]
//
// Removes a pool key from the staker's active pool set - fails if not found (!)
//
// @param {Address} staker - The address of the staker.
// @param {ValidatorPoolKey} poolKey - The pool key they should be stored in
//
// @return [boolean, boolean] [is the staker gone from ALL pools of the given VALIDATOR, and is staker gone from ALL pools]
removeFromStakerPoolSet:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 4

	// contracts/validatorRegistry.algo.ts:1199
	// inSameValidatorPoolCount = 0
	intc 0 // 0
	frame_bury 0 // inSameValidatorPoolCount: uint64

	// contracts/validatorRegistry.algo.ts:1200
	// inAnyPoolCount = 0
	intc 0 // 0
	frame_bury 1 // inAnyPoolCount: uint64

	// contracts/validatorRegistry.algo.ts:1201
	// found = false
	intc 0 // 0
	frame_bury 2 // found: bool

	// contracts/validatorRegistry.algo.ts:1203
	// poolSet = clone(this.stakerPoolSet(staker).value)
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	box_get

	// box value does not exist: this.stakerPoolSet(staker).value
	assert
	frame_bury 3 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:1204
	// for (let i = 0; i < this.stakerPoolSet(staker).value.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_8:
	// contracts/validatorRegistry.algo.ts:1204
	// i < this.stakerPoolSet(staker).value.length
	frame_dig 4 // i: uint64
	intc 7 // 6
	<
	bz *for_8_end

	// *if40_condition
	// contracts/validatorRegistry.algo.ts:1205
	// poolSet[i].id === 0
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if40_end

	// *if40_consequent
	b *for_8_continue

*if40_end:
	// contracts/validatorRegistry.algo.ts:1208
	// inAnyPoolCount += 1
	frame_dig 1 // inAnyPoolCount: uint64
	intc 1 // 1
	+
	frame_bury 1 // inAnyPoolCount: uint64

	// *if41_condition
	// contracts/validatorRegistry.algo.ts:1209
	// poolSet[i].id === poolKey.id
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	extract3
	btoi
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	==
	bz *if41_end

	// *if41_consequent
	// *if42_condition
	// contracts/validatorRegistry.algo.ts:1210
	// poolSet[i] === poolKey
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	intc 3 // 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz *if42_else

	// *if42_consequent
	// contracts/validatorRegistry.algo.ts:1211
	// found = true
	intc 1 // 1
	frame_bury 2 // found: bool

	// contracts/validatorRegistry.algo.ts:1213
	// this.stakerPoolSet(staker).value[i] = { id: 0, poolId: 0, poolAppId: 0 }
	frame_dig 4 // i: uint64
	intc 3 // 24
	* // acc * typeLength
	pushbytes 0x000000000000000000000000000000000000000000000000
	bytec 3 //  "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace
	b *if42_end

*if42_else:
	// contracts/validatorRegistry.algo.ts:1215
	// inSameValidatorPoolCount += 1
	frame_dig 0 // inSameValidatorPoolCount: uint64
	intc 1 // 1
	+
	frame_bury 0 // inSameValidatorPoolCount: uint64

*if42_end:

*if41_end:

*for_8_continue:
	// contracts/validatorRegistry.algo.ts:1204
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_8

*for_8_end:
	// *if43_condition
	// contracts/validatorRegistry.algo.ts:1219
	// !found
	frame_dig 2 // found: bool
	!
	bz *if43_end

	// *if43_consequent
	// No matching slot found when told to remove a pool from the stakers set
	err

*if43_end:
	// contracts/validatorRegistry.algo.ts:1223
	// return [inSameValidatorPoolCount === 0, inAnyPoolCount === 0]
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // inSameValidatorPoolCount: uint64
	intc 0 // 0
	==
	setbit
	intc 1 // 1
	frame_dig 1 // inAnyPoolCount: uint64
	intc 0 // 0
	==
	setbit

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// addPoolToNode(validatorId: ValidatorIdType, poolAppId: uint64, nodeNum: uint64): void
addPoolToNode:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:1227
	// nodePoolAssignments = clone(this.validatorList(validatorId).value.nodePoolAssignments)
	intc 17 //  headOffset
	intc 22 // 192
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // nodePoolAssignments: ((uint64[3])[8])

	// contracts/validatorRegistry.algo.ts:1228
	// maxPoolsPerNodeForThisValidator = this.validatorList(validatorId).value.config.poolsPerNode as uint64
	pushint 225
	intc 1 // 1
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // maxPoolsPerNodeForThisValidator: uint64

	// contracts/validatorRegistry.algo.ts:1230
	// assert(nodeNum >= 1 && nodeNum <= MAX_NODES, 'node number not in valid range')
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	>=
	dup
	bz *skip_and10
	frame_dig -3 // nodeNum: uint64
	intc 2 // 8
	<=
	&&

*skip_and10:
	// node number not in valid range
	assert

	// contracts/validatorRegistry.algo.ts:1232
	// for (let i = 0; i < maxPoolsPerNodeForThisValidator; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_9:
	// contracts/validatorRegistry.algo.ts:1232
	// i < maxPoolsPerNodeForThisValidator
	frame_dig 2 // i: uint64
	frame_dig 1 // maxPoolsPerNodeForThisValidator: uint64
	<
	bz *for_9_end

	// *if44_condition
	// contracts/validatorRegistry.algo.ts:1233
	// nodePoolAssignments.nodes[nodeNum - 1].poolAppIds[i] === 0
	frame_dig 0 // nodePoolAssignments: ((uint64[3])[8])
	intc 0 // 0
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	-
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	intc 2 // 8
	extract3
	btoi
	intc 0 // 0
	==
	bz *if44_end

	// *if44_consequent
	// contracts/validatorRegistry.algo.ts:1235
	// this.validatorList(validatorId).value.nodePoolAssignments.nodes[nodeNum - 1].poolAppIds[i] = poolAppId
	intc 17 // 900
	frame_dig -3 // nodeNum: uint64
	intc 1 // 1
	-
	intc 3 // 24
	* // acc * typeLength
	+
	intc 0 // 0
	+
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	frame_dig -2 // poolAppId: uint64
	itob
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:1236
	// return
	retsub

*if44_end:

*for_9_continue:
	// contracts/validatorRegistry.algo.ts:1232
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_9

*for_9_end:
	// no available space in specified node for this pool
	err
	retsub

// doesStakerMeetGating(validatorId: ValidatorIdType, valueToVerify: uint64): void
//
// Checks if a staker meets the gating requirements specified by the validator.
//
// @param {ValidatorIdType} validatorId - The id of the validator.
// @param {uint64} valueToVerify - The value to verify against the gating requirements.
// @returns {void} or asserts if requirements not met.
doesStakerMeetGating:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 8

	// contracts/validatorRegistry.algo.ts:1250
	// type = this.validatorList(validatorId).value.config.entryGatingType
	intc 36 // 80
	intc 1 // 1
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // type: uint8

	// *if45_condition
	// contracts/validatorRegistry.algo.ts:1251
	// type === GATING_TYPE_NONE
	frame_dig 0 // type: uint8
	intc 0 // 0
	==
	bz *if45_end

	// *if45_consequent
	// contracts/validatorRegistry.algo.ts:1252
	// return
	retsub

*if45_end:
	// contracts/validatorRegistry.algo.ts:1254
	// staker = this.txn.sender
	txn Sender
	frame_bury 1 // staker: address

	// contracts/validatorRegistry.algo.ts:1255
	// config = clone(this.validatorList(validatorId).value.config)
	intc 0 // 0
	intc 9 // 242
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	frame_bury 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)

	// *if46_condition
	// contracts/validatorRegistry.algo.ts:1259
	// type === GATING_TYPE_ASSETS_CREATED_BY ||
	//             type === GATING_TYPE_ASSET_ID ||
	//             type === GATING_TYPE_CREATED_BY_NFD_ADDRESSES
	frame_dig 0 // type: uint8
	intc 1 // 1
	==
	dup
	bnz *skip_or4
	frame_dig 0 // type: uint8
	intc 10 // 2
	==
	||

*skip_or4:
	dup
	bnz *skip_or5
	frame_dig 0 // type: uint8
	intc 8 // 3
	==
	||

*skip_or5:
	bz *if46_end

	// *if46_consequent
	// contracts/validatorRegistry.algo.ts:1263
	// assert(valueToVerify !== 0)
	frame_dig -2 // valueToVerify: uint64
	intc 0 // 0
	!=
	assert

	// contracts/validatorRegistry.algo.ts:1264
	// balRequired = this.validatorList(validatorId).value.config.gatingAssetMinBalance
	intc 37 // 145
	intc 2 // 8
	bytec 0 //  "v"
	frame_dig -1 // validatorId: ValidatorIdType
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 3 // balRequired: uint64

	// *if47_condition
	// contracts/validatorRegistry.algo.ts:1265
	// balRequired === 0
	frame_dig 3 // balRequired: uint64
	intc 0 // 0
	==
	bz *if47_end

	// *if47_consequent
	// contracts/validatorRegistry.algo.ts:1266
	// balRequired = 1
	intc 1 // 1
	frame_bury 3 // balRequired: uint64

*if47_end:
	// contracts/validatorRegistry.algo.ts:1268
	// assert(
	//                 staker.assetBalance(AssetID.fromUint64(valueToVerify)) >= balRequired,
	//                 'must have required minimum balance of validator defined token to add stake',
	//             )
	frame_dig 1 // staker: address
	frame_dig -2 // valueToVerify: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 3 // balRequired: uint64
	>=

	// must have required minimum balance of validator defined token to add stake
	assert

*if46_end:
	// *if48_condition
	// contracts/validatorRegistry.algo.ts:1273
	// type === GATING_TYPE_ASSETS_CREATED_BY
	frame_dig 0 // type: uint8
	intc 1 // 1
	==
	bz *if48_end

	// *if48_consequent
	// contracts/validatorRegistry.algo.ts:1274
	// assert(
	//                 AssetID.fromUint64(valueToVerify).creator === config.entryGatingAddress,
	//                 'specified asset must be created by creator that the validator defined as a requirement to stake',
	//             )
	frame_dig -2 // valueToVerify: uint64
	asset_params_get AssetCreator
	pop
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 81 32
	==

	// specified asset must be created by creator that the validator defined as a requirement to stake
	assert

*if48_end:
	// *if49_condition
	// contracts/validatorRegistry.algo.ts:1279
	// type === GATING_TYPE_ASSET_ID
	frame_dig 0 // type: uint8
	intc 10 // 2
	==
	bz *if49_end

	// *if49_consequent
	// contracts/validatorRegistry.algo.ts:1280
	// found = false
	intc 0 // 0
	frame_bury 4 // found: bool

	// contracts/validatorRegistry.algo.ts:1281
	// config.entryGatingAssets
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 113 32
	dup
	frame_bury 5 // copy of the array we are iterating over
	extract 0 8
	btoi
	frame_bury 6 // assetId: uint64
	intc 0 // 0
	frame_bury 7 // the offset we are extracting the next element from

*forOf_0:
	// *if50_condition
	// contracts/validatorRegistry.algo.ts:1282
	// valueToVerify === assetId
	frame_dig -2 // valueToVerify: uint64
	frame_dig 6 // assetId: uint64
	==
	bz *if50_end

	// *if50_consequent
	// contracts/validatorRegistry.algo.ts:1283
	// found = true
	intc 1 // 1
	frame_bury 4 // found: bool
	b *forOf_0_end

*if50_end:

*forOf_0_continue:
	// increment offset and loop if not out of bounds
	frame_dig 7 // the offset we are extracting the next element from
	intc 2 // 8
	+
	dup
	intc 6 //  offset of last element
	<
	bz *forOf_0_end
	frame_bury 7 // the offset we are extracting the next element from
	frame_dig 5 // copy of the array we are iterating over
	frame_dig 7 // the offset we are extracting the next element from
	intc 2 // 8
	extract
	btoi
	frame_bury 6 // assetId: uint64
	b *forOf_0

*forOf_0_end:
	// contracts/validatorRegistry.algo.ts:1287
	// assert(found, 'specified asset must be identical to the asset id defined as a requirement to stake')
	frame_dig 4 // found: bool

	// specified asset must be identical to the asset id defined as a requirement to stake
	assert

*if49_end:
	// *if51_condition
	// contracts/validatorRegistry.algo.ts:1289
	// type === GATING_TYPE_CREATED_BY_NFD_ADDRESSES
	frame_dig 0 // type: uint8
	intc 8 // 3
	==
	bz *if51_end

	// *if51_consequent
	// contracts/validatorRegistry.algo.ts:1292
	// assert(
	//                 this.isAddressInNFDCAAlgoList(config.entryGatingAssets[0], AssetID.fromUint64(valueToVerify).creator),
	//                 'specified asset must be created by creator that is one of the linked addresses in an nfd',
	//             )
	frame_dig -2 // valueToVerify: uint64
	asset_params_get AssetCreator
	pop
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 113 8
	btoi
	callsub isAddressInNFDCAAlgoList

	// specified asset must be created by creator that is one of the linked addresses in an nfd
	assert

*if51_end:
	// *if52_condition
	// contracts/validatorRegistry.algo.ts:1297
	// type === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig 0 // type: uint8
	intc 15 // 4
	==
	bz *if52_end

	// *if52_consequent
	// contracts/validatorRegistry.algo.ts:1299
	// userOfferedNFDAppID = valueToVerify
	frame_dig -2 // valueToVerify: uint64
	frame_bury 8 // userOfferedNFDAppID: uint64

	// contracts/validatorRegistry.algo.ts:1300
	// assert(this.isNFDAppIDValid(userOfferedNFDAppID), 'provided NFD must be valid')
	frame_dig 8 // userOfferedNFDAppID: uint64
	callsub isNFDAppIDValid

	// provided NFD must be valid
	assert

	// contracts/validatorRegistry.algo.ts:1303
	// assert(
	//                 rawBytes(AppID.fromUint64(userOfferedNFDAppID).globalState('i.owner.a') as Address) ===
	//                     rawBytes(staker) || this.isAddressInNFDCAAlgoList(userOfferedNFDAppID, staker),
	//                 "provided nfd for entry isn't owned or linked to the staker",
	//             )
	frame_dig 8 // userOfferedNFDAppID: uint64
	bytec 10 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(userOfferedNFDAppID).globalState('i.owner.a')
	assert
	frame_dig 1 // staker: address
	==
	dup
	bnz *skip_or6
	frame_dig 1 // staker: address
	frame_dig 8 // userOfferedNFDAppID: uint64
	callsub isAddressInNFDCAAlgoList
	||

*skip_or6:
	// provided nfd for entry isn't owned or linked to the staker
	assert

	// contracts/validatorRegistry.algo.ts:1310
	// assert(
	//                 btoi(AppID.fromUint64(userOfferedNFDAppID).globalState('i.parentAppID') as bytes) ===
	//                     config.entryGatingAssets[0],
	//                 'specified nfd must be a segment of the nfd the validator specified as a requirement',
	//             )
	frame_dig 8 // userOfferedNFDAppID: uint64
	pushbytes 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(userOfferedNFDAppID).globalState('i.parentAppID')
	assert
	btoi
	frame_dig 2 // config: (uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)
	extract 113 8
	btoi
	==

	// specified nfd must be a segment of the nfd the validator specified as a requirement
	assert

*if52_end:
	retsub

// isNFDAppIDValid(nfdAppID: uint64): boolean
//
// Checks if the given NFD App id is valid.  Using only the App id there's no validation against the name (ie: that nfd X is name Y)
// So it's assumed for the caller, the app id alone is fine.  The name is fetched from the specified app id and the two
// together are used for validity check call to the nfd registry.
//
// @param {uint64} nfdAppID - The NFD App id to verify.
//
// @returns {boolean} - Returns true if the NFD App id is valid, otherwise false.
isNFDAppIDValid:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/validatorRegistry.algo.ts:1329
	// userOfferedNFDName = AppID.fromUint64(nfdAppID).globalState('i.name') as string
	frame_dig -1 // nfdAppID: uint64
	pushbytes 0x692e6e616d65 // "i.name"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.name')
	assert
	frame_bury 0 // userOfferedNFDName: string

	// contracts/validatorRegistry.algo.ts:1331
	// return sendMethodCall<[string, uint64], boolean>({
	//             applicationID: AppID.fromUint64(this.nfdRegistryAppId),
	//             name: 'isValidNfdAppId',
	//             methodArgs: [userOfferedNFDName, nfdAppID],
	//         })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum
	pushbytes 0x4be22fc6 // method "isValidNfdAppId(string,uint64)bool"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:1332
	// applicationID: AppID.fromUint64(this.nfdRegistryAppId)
	intc 28 // TMPL_nfdRegistryAppId
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:1334
	// methodArgs: [userOfferedNFDName, nfdAppID]
	frame_dig 0 // userOfferedNFDName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // nfdAppID: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit

	// set the subroutine return value
	frame_bury 0
	retsub

// isAddressInNFDCAAlgoList(nfdAppID: uint64, addrToFind: Address): boolean
//
// Checks if the specified address is present in an NFDs list of verified addresses.
// The NFD is assumed to have already been validated as official.
//
// @param {uint64} nfdAppID - The NFD application id.
// @param {Address} addrToFind - The address to find in the v.caAlgo.0.as property
// @return {boolean} - `true` if the address is present, `false` otherwise.
isAddressInNFDCAAlgoList:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:1347
	// sendAppCall({
	//             applicationID: AppID.fromUint64(nfdAppID),
	//             applicationArgs: ['read_property', 'v.caAlgo.0.as'],
	//         })
	itxn_begin
	intc 7 //  appl
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:1348
	// applicationID: AppID.fromUint64(nfdAppID)
	frame_dig -1 // nfdAppID: uint64
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:1349
	// applicationArgs: ['read_property', 'v.caAlgo.0.as']
	pushbytes 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	pushbytes 0x762e6361416c676f2e302e6173 // "v.caAlgo.0.as"
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:1351
	// caAlgoData = this.itxn.lastLog
	itxn LastLog
	frame_bury 0 // caAlgoData: byte[]

	// contracts/validatorRegistry.algo.ts:1352
	// for (let i = 0; i < caAlgoData.length; i += 32)
	intc 0 // 0
	frame_bury 1 // i: uint64

*for_10:
	// contracts/validatorRegistry.algo.ts:1352
	// i < caAlgoData.length
	frame_dig 1 // i: uint64
	frame_dig 0 // caAlgoData: byte[]
	len
	<
	bz *for_10_end

	// contracts/validatorRegistry.algo.ts:1353
	// addr = extract3(caAlgoData, i, 32)
	frame_dig 0 // caAlgoData: byte[]
	frame_dig 1 // i: uint64
	intc 6 // 32
	extract3
	frame_bury 2 // addr: byte[]

	// *if53_condition
	// contracts/validatorRegistry.algo.ts:1354
	// addr !== rawBytes(globals.zeroAddress) && addr === rawBytes(addrToFind)
	frame_dig 2 // addr: byte[]
	global ZeroAddress
	!=
	dup
	bz *skip_and11
	frame_dig 2 // addr: byte[]
	frame_dig -2 // addrToFind: Address
	==
	&&

*skip_and11:
	bz *if53_end

	// *if53_consequent
	// contracts/validatorRegistry.algo.ts:1355
	// return true
	intc 1 // 1
	b *isAddressInNFDCAAlgoList*return

*if53_end:

*for_10_continue:
	// contracts/validatorRegistry.algo.ts:1352
	// i += 32
	frame_dig 1 // i: uint64
	intc 6 // 32
	+
	frame_bury 1 // i: uint64
	b *for_10

*for_10_end:
	// contracts/validatorRegistry.algo.ts:1358
	// return false
	intc 0 // 0

*isAddressInNFDCAAlgoList*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// algoSaturationLevel(): uint64
//
// Returns the maximum allowed stake per validator based on a percentage of all current online stake before
// the validator is considered saturated - where rewards are diminished.
// NOTE: this function is defined twice - here and in staking pool contract.  Both must be identical.
algoSaturationLevel:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/validatorRegistry.algo.ts:1367
	// online = this.getCurrentOnlineStake()
	callsub getCurrentOnlineStake
	frame_bury 0 // online: uint64

	// contracts/validatorRegistry.algo.ts:1369
	// return wideRatio([online, MAX_VALIDATOR_SOFT_PCT_OF_ONLINE_1DECIMAL], [1000])
	frame_dig 0 // online: uint64
	pushint 100
	mulw
	intc 0 // 0
	intc 32 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// maxAllowedStake(): uint64
//
// Returns the MAXIMUM allowed stake per validator based on a percentage of all current online stake.
// Adding stake is completely blocked at this amount.
maxAllowedStake:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/validatorRegistry.algo.ts:1377
	// online = this.getCurrentOnlineStake()
	callsub getCurrentOnlineStake
	frame_bury 0 // online: uint64

	// contracts/validatorRegistry.algo.ts:1379
	// return wideRatio([online, MAX_VALIDATOR_HARD_PCT_OF_ONLINE_1DECIMAL], [1000])
	frame_dig 0 // online: uint64
	pushint 150
	mulw
	intc 0 // 0
	intc 32 // 1000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// maxAlgoAllowedPerPool(): uint64
//
// Returns the MAXIMUM allowed stake per pool and still receive incentives - we'll treat this as the 'max per pool'
maxAlgoAllowedPerPool:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:1386
	// return globals.payoutsMaxBalance
	global PayoutsMaxBalance
	retsub

// getCurrentOnlineStake(): uint64
getCurrentOnlineStake:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:1390
	// return onlineStake()
	online_stake
	retsub

// minBalanceForAccount(contracts: uint64, extraPages: uint64, assets: uint64, localInts: uint64, localBytes: uint64, globalInts: uint64, globalBytes: uint64): uint64
minBalanceForAccount:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/validatorRegistry.algo.ts:1402
	// minBal = ALGORAND_ACCOUNT_MIN_BALANCE
	intc 16 // 100000
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1403
	// minBal += contracts * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -1 // contracts: uint64
	intc 16 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1404
	// minBal += extraPages * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -2 // extraPages: uint64
	intc 16 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1405
	// minBal += assets * ASSET_HOLDING_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -3 // assets: uint64
	intc 16 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1406
	// minBal += localInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -4 // localInts: uint64
	intc 33 // 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1407
	// minBal += globalInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -6 // globalInts: uint64
	intc 33 // 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1408
	// minBal += localBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -5 // localBytes: uint64
	intc 34 // 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1409
	// minBal += globalBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -7 // globalBytes: uint64
	intc 34 // 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:1410
	// return minBal
	frame_dig 0 // minBal: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:1417
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE
	pushint 2500
	frame_dig -1 // totalNumBytes: uint64
	pushint 400
	*
	+
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x1b5e82c6 // method "initStakingContract(uint64)void"
	pushbytes 0x79472d83 // method "loadStakingContractData(uint64,byte[])void"
	pushbytes 0x5f7acfd9 // method "finalizeStakingContract()void"
	pushbytes 0x3172ca9d // method "gas()void"
	pushbytes 0x8a87142d // method "getMbrAmounts()(uint64,uint64,uint64,uint64)"
	pushbytes 0xd1366cc3 // method "getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
	pushbytes 0x3b045c5c // method "getNumValidators()uint64"
	pushbytes 0x75aff61d // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
	pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
	pushbytes 0x2fa22c4b // method "getValidatorOwnerAndManager(uint64)(address,address)"
	pushbytes 0x910e94ac // method "getPools(uint64)(uint64,uint16,uint64)[]"
	pushbytes 0x572767d1 // method "getPoolAppId(uint64,uint64)uint64"
	pushbytes 0x9b504aaf // method "getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)"
	pushbytes 0xfbc63178 // method "getCurMaxStakePerPool(uint64)uint64"
	pushbytes 0x24498cf4 // method "doesStakerNeedToPayMBR(address)bool"
	pushbytes 0xf846dd7a // method "getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]"
	pushbytes 0x83050501 // method "getTokenPayoutRatio(uint64)(uint64[24],uint64)"
	pushbytes 0x7bbb6c8d // method "getNodePoolAssignments(uint64)((uint64[3])[8])"
	pushbytes 0xf839414a // method "getNFDRegistryID()uint64"
	pushbytes 0x0c317cfb // method "addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64"
	pushbytes 0x3e288972 // method "changeValidatorManager(uint64,address)void"
	pushbytes 0xdd5faada // method "changeValidatorSunsetInfo(uint64,uint64,uint64)void"
	pushbytes 0x18aac7a7 // method "changeValidatorNFD(uint64,uint64,string)void"
	pushbytes 0xf99ef54d // method "changeValidatorCommissionAddress(uint64,address)void"
	pushbytes 0x10809d4d // method "changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void"
	pushbytes 0xe778dd5a // method "addPool(pay,uint64,uint64)(uint64,uint64,uint64)"
	pushbytes 0xbf5259d0 // method "addStake(pay,uint64,uint64)(uint64,uint64,uint64)"
	pushbytes 0x4df8d86e // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
	pushbytes 0x418fcefc // method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void"
	pushbytes 0xa2dc51b5 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
	pushbytes 0x2873f504 // method "findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)"
	pushbytes 0x0547f4fe // method "movePoolToNode(uint64,uint64,uint64)void"
	pushbytes 0xcb668358 // method "emptyTokenRewards(uint64,address)uint64"
	txna ApplicationArgs 0
	match *abi_route_initStakingContract *abi_route_loadStakingContractData *abi_route_finalizeStakingContract *abi_route_gas *abi_route_getMbrAmounts *abi_route_getProtocolConstraints *abi_route_getNumValidators *abi_route_getValidatorConfig *abi_route_getValidatorState *abi_route_getValidatorOwnerAndManager *abi_route_getPools *abi_route_getPoolAppId *abi_route_getPoolInfo *abi_route_getCurMaxStakePerPool *abi_route_doesStakerNeedToPayMBR *abi_route_getStakedPoolsForAccount *abi_route_getTokenPayoutRatio *abi_route_getNodePoolAssignments *abi_route_getNFDRegistryID *abi_route_addValidator *abi_route_changeValidatorManager *abi_route_changeValidatorSunsetInfo *abi_route_changeValidatorNFD *abi_route_changeValidatorCommissionAddress *abi_route_changeValidatorRewardInfo *abi_route_addPool *abi_route_addStake *abi_route_setTokenPayoutRatio *abi_route_stakeUpdatedViaRewards *abi_route_stakeRemoved *abi_route_findPoolForStaker *abi_route_movePoolToNode *abi_route_emptyTokenRewards

	// this contract does not implement the given ABI method for call NoOp
	err